module APD_i2c_control(
	Clk,
	Rst_n,
	rdreg_req,
	rddata,
	RW_Done,
	ack,
	i2c_sclk,
	i2c_sdat,
	COLOR);

	//---Ports declearation: generated by Robei---
	input Clk;
	input Rst_n;
	input rdreg_req;
	output [63:0] rddata;
	output RW_Done;
	output ack;
	output i2c_sclk;
	inout i2c_sdat;
	output [7:0] COLOR;

	wire Clk;
	wire Rst_n;
	wire rdreg_req;
	reg [63:0] rddata;
	reg RW_Done;
	reg ack;
	wire i2c_sclk;
	wire i2c_sdat;
	reg [7:0] COLOR;

	//----Code starts here: integrated by Robei-----
				localparam  APD_address=7'b011_1001; 
				localparam  APD_begin_value=8'b0000_0011; 	
				
				localparam  APD_begin=8'h80; 
				
				localparam  Clear_Low=8'h94; 
				localparam  Clear_High=8'h95; 
				
				localparam  Red_Low=8'h96; 
				localparam  Red_High=8'h97; 
				
				localparam  Green_Low=8'h98; 
				localparam  Green_High=8'h99; 		
			
				localparam  Blue_Low=8'h9A; 
				localparam  Blue_High=8'h9B; 	
				
				
				/***********颜色识别程序参数在这里调*********/
				
				localparam  clear_small=8'h10; 
				
				localparam  clear_middle=8'h35; 
				
				localparam  clear_big=8'h70;
				
				localparam  BLACK=8'h1; 
				localparam  WHITE=8'h2; 
				localparam  YELLOW=8'h3;			
				localparam  RED=8'h4; 
				localparam  GREEN=8'h5; 
				localparam  BLUE=8'h6;			
	
				/****************************************/
				
				
			
			
				//颜色数值缓存
				reg [5:0]Cmd;
				reg [7:0]Tx_DATA;
				
				reg [7:0]Temp_CL;
				reg [7:0]Temp_CH;
				
				reg [7:0]Temp_RL;
				reg [7:0]Temp_RH;
				
				reg [7:0]Temp_GL;
				reg [7:0]Temp_GH;
				
				reg [7:0]Temp_BL;
				reg [7:0]Temp_BH;
				
				reg [63:0] Color_data;
				
				
				
				wire Trans_Done;
				wire ack_o;
				reg Go;
			
				//buffer for input data or out put data
		
				
			
				
				wire [7:0]Rx_DATA;
				reg [63:0] data_LM75A; //temperature data
				
				localparam 
					WR   = 6'b000001,   //写请求
					STA  = 6'b000010,   //起始位请求
					RD   = 6'b000100,   //读请求
					STO  = 6'b001000,   //停止位请求
					ACK  = 6'b010000,   //应答位请求
					NACK = 6'b100000;   //无应答请求
			
			
				
				reg [6:0]state;
				reg [7:0]cnt;
				reg init_flag;
				
				localparam
					IDLE         = 7'b0000001,   //空闲状态
					WR_REG       = 7'b0000010,   //写寄存器状态
					WAIT_WR_DONE = 7'b0000100,   //等待写寄存器完成状态
					WR_REG_DONE  = 7'b0001000,   //写寄存器完成状态
					RD_REG       = 7'b0010000,   //读寄存器状态
					WAIT_RD_DONE = 7'b0100000,   //等待读寄存器完成状态
					RD_REG_DONE  = 7'b1000000;   //读寄存器完成状态
				
				always@(posedge Clk or negedge Rst_n)
				begin
				if(!Rst_n)begin
					Cmd <= 6'd0;
					Tx_DATA <= 8'd0;
					
					Temp_CL <= 8'd0;
					Temp_CH <= 8'd0;
					
					Temp_RL <= 8'd0;
					Temp_RH <= 8'd0;
					
					Temp_GL <= 8'd0;
					Temp_GH <= 8'd0;
					
					Temp_BL <= 8'd0;
					Temp_BH <= 8'd0;
					
					init_flag <= 1'b0;
					Go <= 1'b0;
					rddata <= 0;
					state <= IDLE;
					ack <= 0;
				end
				else begin
					case(state)
						IDLE:
							begin
								cnt <= 0;
								ack <= 0;
								RW_Done <= 1'b0;					
								if(rdreg_req)
									state <= RD_REG;
								else
									state <= IDLE;
							end					
							
						RD_REG:
							begin
								state <= WAIT_RD_DONE;
								if(init_flag == 0)
									begin
										cnt <= 32;
										init_flag <= 1;
									end
									
								case(cnt)
									0:write_byte(WR | STA, {APD_address,1'b0});			//发送APD的地址和读信号（1）
									1:write_byte(WR , Clear_Low);
									2:write_byte(WR | STA, {APD_address,1'b1});	
									3:read_byte(RD | NACK | STO);
		
									4:write_byte(WR | STA, {APD_address,1'b0});			//发送APD的地址和读信号（1）
									5:write_byte(WR , Clear_High);
									6:write_byte(WR | STA, {APD_address,1'b1});	
									7:read_byte(RD | NACK | STO);	
									
									8:write_byte(WR | STA, {APD_address,1'b0});			//发送APD的地址和读信号（1）
									9:write_byte(WR , Red_Low);
									10:write_byte(WR | STA, {APD_address,1'b1});	
									11:read_byte(RD | NACK | STO);
		
									12:write_byte(WR | STA, {APD_address,1'b0});			//发送APD的地址和读信号（1）
									13:write_byte(WR , Red_High);
									14:write_byte(WR | STA, {APD_address,1'b1});	
									15:read_byte(RD | NACK | STO);			
		
									16:write_byte(WR | STA, {APD_address,1'b0});			//发送APD的地址和读信号（1）
									17:write_byte(WR , Green_Low);
									18:write_byte(WR | STA, {APD_address,1'b1});	
									19:read_byte(RD | NACK | STO);
		
									20:write_byte(WR | STA, {APD_address,1'b0});			//发送APD的地址和读信号（1）
									21:write_byte(WR , Green_High);
									22:write_byte(WR | STA, {APD_address,1'b1});	
									23:read_byte(RD | NACK | STO);	
									
									24:write_byte(WR | STA, {APD_address,1'b0});			//发送APD的地址和读信号（1）
									25:write_byte(WR , Blue_Low);
									26:write_byte(WR | STA, {APD_address,1'b1});	
									27:read_byte(RD | NACK | STO);
		
									28:write_byte(WR | STA, {APD_address,1'b0});			//发送APD的地址和读信号（1）
									29:write_byte(WR , Blue_High);
									30:write_byte(WR | STA, {APD_address,1'b1});	
									31:read_byte(RD | NACK | STO);				
									
									32:write_byte(WR | STA, {APD_address,1'b0});			//发送APD的地址和读信号（1）
									33:write_byte(WR , APD_begin);
									34:write_byte(WR | STO, APD_begin_value);	
															
														
									default:;
								endcase
							end
							
						WAIT_RD_DONE:
							begin
								Go <= 1'b0; 
								if(Trans_Done)begin
									if(cnt <= 1) ack <= ack | ack_o;
									case(cnt)
										0: begin cnt <= 1; state <= RD_REG;end
										1: begin cnt <= 2; state <= RD_REG;end
										2: begin cnt <= 3; state <= RD_REG;end								
										3: 
											begin 
												Temp_CL <= Rx_DATA;
												cnt <= 4;
												state <= RD_REG;	
											end
											
										4: begin cnt <= 5; state <= RD_REG;end
										5: begin cnt <= 6; state <= RD_REG;end
										6: begin cnt <= 7; state <= RD_REG;end								
										7: 
											begin 
												Temp_CH <= Rx_DATA;
												cnt <= 8;
												state <= RD_REG;	
											end									
											
										8: begin cnt <= 9; state <= RD_REG;end
										9: begin cnt <= 10; state <= RD_REG;end
										10: begin cnt <= 11; state <= RD_REG;end								
										11: 
											begin 
												Temp_RL <= Rx_DATA;
												cnt <= 12;
												state <= RD_REG;	
											end
											
										12: begin cnt <= 13; state <= RD_REG;end
										13: begin cnt <= 14; state <= RD_REG;end
										14: begin cnt <= 15; state <= RD_REG;end								
										15: 
											begin 
												Temp_RH <= Rx_DATA;
												cnt <= 16;
												state <= RD_REG;	
											end										
											
										16: begin cnt <= 17; state <= RD_REG;end
										17: begin cnt <= 18; state <= RD_REG;end
										18: begin cnt <= 19; state <= RD_REG;end								
										19: 
											begin 
												Temp_GL <= Rx_DATA;
												cnt <= 20;
												state <= RD_REG;	
											end
											
										20: begin cnt <= 21; state <= RD_REG;end
										21: begin cnt <= 22; state <= RD_REG;end
										22: begin cnt <= 23; state <= RD_REG;end								
										23: 
											begin 
												Temp_GH <= Rx_DATA;
												cnt <= 24;
												state <= RD_REG;	
											end									
											
										24: begin cnt <= 25; state <= RD_REG;end
										25: begin cnt <= 26; state <= RD_REG;end
										26: begin cnt <= 27; state <= RD_REG;end								
										27: 
											begin 
												Temp_BL <= Rx_DATA;
												cnt <= 28;
												state <= RD_REG;	
											end
											
										28: begin cnt <= 29; state <= RD_REG;end
										29: begin cnt <= 30; state <= RD_REG;end
										30: begin cnt <= 31; state <= RD_REG;end								
										31: 
											begin 
												Temp_BH <= Rx_DATA;
												cnt <= 0;
												state <= RD_REG_DONE;	
											end	
										
										
										
										32: begin cnt <= 33; state <= RD_REG;end
										33: begin cnt <= 34; state <= RD_REG;end
										34: 								
											begin 
												state <= IDLE;
												cnt <= 0;
											end									
																			
										default:state <= IDLE;
									endcase
								end
							end
						
						
						RD_REG_DONE:
							begin
								RW_Done <= 1'b1;
								Color_data <= {Temp_CL,Temp_CH,Temp_RL,Temp_RH,Temp_GL,Temp_GH,Temp_BL,Temp_BH};
								rddata <= Color_data;
								state <= IDLE;				
							end
						default:state <= IDLE;
					endcase
				end
				end
				
				/*************************************************颜色识别程序**********************************************************/
				
				reg [7:0]clear_value;
				reg [7:0]red_value;
				reg [7:0]green_value;
				reg [7:0]blue_value;
				
				always@(posedge Clk or negedge Rst_n)
					begin
	
						if(!Rst_n)
							begin
								COLOR <= 0;
								clear_value <= 0;
								red_value <= 0;
								green_value <= 0;
								blue_value <= 0;
							end
						
						else 
							begin
								clear_value <= Color_data[63:56];
								red_value <= Color_data[47:40];
								green_value <= Color_data[31:24];
								blue_value <= Color_data[15:8];
								if(clear_value < clear_small)
									begin
										COLOR <= BLACK;
									end
								else
									begin
										if(clear_value < clear_middle)
											begin
												if(red_value < green_value) COLOR <= GREEN;
												else COLOR <= RED;
											end	
										else
											begin
												if((green_value>red_value)&&(green_value>blue_value)) COLOR <= YELLOW;
												else
													begin
														if(clear_value < clear_big) COLOR <= BLUE;
														else COLOR <= WHITE;
														
													end
											end
									end						
							end
					end
				
				
				
				
				/******************************************************************************************************************/
			
				task read_byte;
					input [5:0]Ctrl_Cmd;
					begin
						Cmd <= Ctrl_Cmd;
						Go <= 1'b1; 
					end
				endtask
				
				task write_byte;
					input [5:0]Ctrl_Cmd;
					input [7:0]Wr_Byte_Data;
					begin
						Cmd <= Ctrl_Cmd;
						Tx_DATA <= Wr_Byte_Data;
						Go <= 1'b1; 
					end
				endtask
	//---Module instantiation---
	APD_i2c_bit_shifter APD_i2c_bit_shifter2(
		.Clk(Clk),
		.Rst_n(Rst_n),
		.Cmd(Cmd),
		.Go(Go),
		.Tx_DATA(Tx_DATA),
		.Rx_DATA(Rx_DATA),
		.Trans_Done(Trans_Done),
		.ack_o(ack_o),
		.i2c_sclk(i2c_sclk),
		.i2c_sdat(i2c_sdat));

endmodule    //APD_i2c_control

