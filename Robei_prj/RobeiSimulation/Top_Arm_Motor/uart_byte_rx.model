<!DOCTYPE Robei>
<Module Type="module" Width="900" X="0" Class="module" Color="#d3d3d3" Parent="0" Parameters="" Comment="" Height="600" Include="" Y="0" File="Current/uart_byte_rx.model" Name="uart_byte_rx" Code="/*&#xa;在实际工业应用中，现场往往有非常强的电磁干扰，只采样一次就作为该数据的电&#xa;平状态是不可靠的。 很有可能恰好采集到被干扰的信号而导致结果出错，因此这里提出以下&#xa;改进型的单 bit 数据接收方式示意图，使用多次采样求概率的方式进行状态判定&#xa;将每一位数据再平均分成了 16 小段&#xa;&#xa;clk I 模块系统时钟 50MHz&#xa;reset_n I 模块异步复位信号&#xa;uart_rx I 串行数据输入&#xa;baud_set I 波特率选择信号&#xa;data_byte O 并行数据输出&#xa;rx_done O 接收结束信号&#xa;&#xa;*/&#xa;&#xa;&#xa;&#x9;wire reset=~reset_n;&#xa;&#xa;&#xa;&#x9;reg uart_rx_sync1;   //同步寄存器&#xa;&#x9;reg uart_rx_sync2;   //同步寄存器&#xa;&#xa;&#x9;reg uart_rx_reg1;    //数据寄存器&#xa;&#x9;reg uart_rx_reg2;    //数据寄存器&#xa;&#xa;&#x9;reg [15:0]bps_DR;    //分频计数最大值&#x9;&#xa;&#x9;reg [15:0]div_cnt;   //分频计数器&#xa;&#x9;reg bps_clk;   //波特率时钟&#x9;&#xa;&#x9;reg [7:0] bps_cnt;   //波特率时钟计数器&#x9;&#xa;&#x9;reg uart_state;//接收数据状态&#xa;&#xa;&#x9;wire uart_rx_nedge;  &#xa;&#xa;&#x9;reg [2:0]START_BIT;&#xa;&#x9;reg [2:0]STOP_BIT;&#xa;&#x9;reg [2:0]data_byte_pre [7:0];&#xa;&#xa;&#x9;//同步串行输入信号，消除亚稳态&#xa;&#x9;always@(posedge clk or posedge reset)&#xa;&#x9;if(reset)begin&#xa;&#x9;&#x9;uart_rx_sync1 &lt;= 1'b0;&#xa;&#x9;&#x9;uart_rx_sync2 &lt;= 1'b0;&#x9;&#xa;&#x9;end&#xa;&#x9;else begin&#xa;&#x9;&#x9;uart_rx_sync1 &lt;= uart_rx;&#xa;&#x9;&#x9;uart_rx_sync2 &lt;= uart_rx_sync1;&#x9;&#xa;&#x9;end&#xa;&#x9;&#xa;&#x9;//数据寄存器&#xa;&#x9;always@(posedge clk or posedge reset)&#xa;&#x9;if(reset)begin&#xa;&#x9;&#x9;uart_rx_reg1 &lt;= 1'b0;&#xa;&#x9;&#x9;uart_rx_reg2 &lt;= 1'b0;&#x9;&#xa;&#x9;end&#xa;&#x9;else begin&#xa;&#x9;&#x9;uart_rx_reg1 &lt;= uart_rx_sync2;&#xa;&#x9;&#x9;uart_rx_reg2 &lt;= uart_rx_reg1;&#x9;&#xa;&#x9;end&#xa;&#x9;&#xa;  //下降沿检测&#xa;&#x9;assign uart_rx_nedge = !uart_rx_reg1 &amp; uart_rx_reg2;&#xa;&#x9;&#xa;&#x9;always@(posedge clk or posedge reset)&#xa;&#x9;if(reset)&#xa;&#x9;&#x9;bps_DR &lt;= 16'd324;&#xa;&#x9;else begin&#xa;&#x9;&#x9;case(baud_set)&#xa;&#x9;&#x9;&#x9;0:bps_DR &lt;= 16'd324;&#xa;&#x9;&#x9;&#x9;1:bps_DR &lt;= 16'd162;&#xa;&#x9;&#x9;&#x9;2:bps_DR &lt;= 16'd80;&#xa;&#x9;&#x9;&#x9;3:bps_DR &lt;= 16'd53;&#xa;&#x9;&#x9;&#x9;4:bps_DR &lt;= 16'd26;&#xa;&#x9;&#x9;&#x9;default:bps_DR &lt;= 16'd324;&#x9;&#x9;&#x9;&#xa;&#x9;&#x9;endcase&#xa;&#x9;end&#xa;&#x9;&#xa;&#x9;//counter&#xa;&#x9;always@(posedge clk or posedge reset)&#xa;&#x9;if(reset)&#xa;&#x9;&#x9;div_cnt &lt;= 16'd0;&#xa;&#x9;else if(uart_state)begin&#xa;&#x9;&#x9;if(div_cnt == bps_DR)&#xa;&#x9;&#x9;&#x9;div_cnt &lt;= 16'd0;&#xa;&#x9;&#x9;else&#xa;&#x9;&#x9;&#x9;div_cnt &lt;= div_cnt + 1'b1;&#xa;&#x9;end&#xa;&#x9;else&#xa;&#x9;&#x9;div_cnt &lt;= 16'd0;&#xa;&#x9;&#x9;&#xa;&#x9;// bps_clk gen&#xa;&#x9;always@(posedge clk or posedge reset)&#xa;&#x9;if(reset)&#xa;&#x9;&#x9;bps_clk &lt;= 1'b0;&#xa;&#x9;else if(div_cnt == 16'd1)&#xa;&#x9;&#x9;bps_clk &lt;= 1'b1;&#xa;&#x9;else&#xa;&#x9;&#x9;bps_clk &lt;= 1'b0;&#xa;&#x9;&#xa;&#x9;//bps counter&#xa;&#x9;always@(posedge clk or posedge reset)&#xa;&#x9;if(reset)&#x9;&#xa;&#x9;&#x9;bps_cnt &lt;= 8'd0;&#xa;&#x9;else if(bps_cnt == 8'd159 | (bps_cnt == 8'd12 &amp;&amp; (START_BIT > 2)))&#xa;&#x9;&#x9;bps_cnt &lt;= 8'd0;&#xa;&#x9;else if(bps_clk)&#xa;&#x9;&#x9;bps_cnt &lt;= bps_cnt + 1'b1;&#xa;&#x9;else&#xa;&#x9;&#x9;bps_cnt &lt;= bps_cnt;&#xa;&#xa;&#x9;always@(posedge clk or posedge reset)&#xa;&#x9;if(reset)&#xa;&#x9;&#x9;rx_done &lt;= 1'b0;&#xa;&#x9;else if(bps_cnt == 8'd159)&#xa;&#x9;&#x9;rx_done &lt;= 1'b1;&#xa;&#x9;else&#xa;&#x9;&#x9;rx_done &lt;= 1'b0;&#x9;&#x9;&#xa;&#x9;&#x9;&#xa;&#x9;always@(posedge clk or posedge reset)&#xa;&#x9;if(reset)begin&#xa;&#x9;&#x9;START_BIT &lt;= 3'd0;&#xa;&#x9;&#x9;data_byte_pre[0] &lt;= 3'd0;&#xa;&#x9;&#x9;data_byte_pre[1] &lt;= 3'd0;&#xa;&#x9;&#x9;data_byte_pre[2] &lt;= 3'd0;&#xa;&#x9;&#x9;data_byte_pre[3] &lt;= 3'd0;&#xa;&#x9;&#x9;data_byte_pre[4] &lt;= 3'd0;&#xa;&#x9;&#x9;data_byte_pre[5] &lt;= 3'd0;&#xa;&#x9;&#x9;data_byte_pre[6] &lt;= 3'd0;&#xa;&#x9;&#x9;data_byte_pre[7] &lt;= 3'd0;&#xa;&#x9;&#x9;STOP_BIT &lt;= 3'd0;&#xa;&#x9;end&#xa;&#x9;else if(bps_clk)begin&#xa;&#x9;&#x9;case(bps_cnt)&#xa;&#x9;&#x9;&#x9;0:begin&#xa;        START_BIT &lt;= 3'd0;&#xa;        data_byte_pre[0] &lt;= 3'd0;&#xa;        data_byte_pre[1] &lt;= 3'd0;&#xa;        data_byte_pre[2] &lt;= 3'd0;&#xa;        data_byte_pre[3] &lt;= 3'd0;&#xa;        data_byte_pre[4] &lt;= 3'd0;&#xa;        data_byte_pre[5] &lt;= 3'd0;&#xa;        data_byte_pre[6] &lt;= 3'd0;&#xa;        data_byte_pre[7] &lt;= 3'd0;&#xa;        STOP_BIT &lt;= 3'd0;&#x9;&#x9;&#x9;&#xa;      end&#xa;&#x9;&#x9;&#x9;6 ,7 ,8 ,9 ,10,11:START_BIT &lt;= START_BIT + uart_rx_sync2;&#xa;&#x9;&#x9;&#x9;22,23,24,25,26,27:data_byte_pre[0] &lt;= data_byte_pre[0] + uart_rx_sync2;&#xa;&#x9;&#x9;&#x9;38,39,40,41,42,43:data_byte_pre[1] &lt;= data_byte_pre[1] + uart_rx_sync2;&#xa;&#x9;&#x9;&#x9;54,55,56,57,58,59:data_byte_pre[2] &lt;= data_byte_pre[2] + uart_rx_sync2;&#xa;&#x9;&#x9;&#x9;70,71,72,73,74,75:data_byte_pre[3] &lt;= data_byte_pre[3] + uart_rx_sync2;&#xa;&#x9;&#x9;&#x9;86,87,88,89,90,91:data_byte_pre[4] &lt;= data_byte_pre[4] + uart_rx_sync2;&#xa;&#x9;&#x9;&#x9;102,103,104,105,106,107:data_byte_pre[5] &lt;= data_byte_pre[5] + uart_rx_sync2;&#xa;&#x9;&#x9;&#x9;118,119,120,121,122,123:data_byte_pre[6] &lt;= data_byte_pre[6] + uart_rx_sync2;&#xa;&#x9;&#x9;&#x9;134,135,136,137,138,139:data_byte_pre[7] &lt;= data_byte_pre[7] + uart_rx_sync2;&#xa;&#x9;&#x9;&#x9;150,151,152,153,154,155:STOP_BIT &lt;= STOP_BIT + uart_rx_sync2;&#xa;&#x9;&#x9;&#x9;default:&#xa;      begin&#xa;        START_BIT &lt;= START_BIT;&#xa;        data_byte_pre[0] &lt;= data_byte_pre[0];&#xa;        data_byte_pre[1] &lt;= data_byte_pre[1];&#xa;        data_byte_pre[2] &lt;= data_byte_pre[2];&#xa;        data_byte_pre[3] &lt;= data_byte_pre[3];&#xa;        data_byte_pre[4] &lt;= data_byte_pre[4];&#xa;        data_byte_pre[5] &lt;= data_byte_pre[5];&#xa;        data_byte_pre[6] &lt;= data_byte_pre[6];&#xa;        data_byte_pre[7] &lt;= data_byte_pre[7];&#xa;        STOP_BIT &lt;= STOP_BIT;&#xa;      end&#xa;&#x9;&#x9;endcase&#xa;&#x9;end&#xa;&#xa;&#x9;always@(posedge clk or posedge reset)&#xa;&#x9;if(reset)&#xa;&#x9;&#x9;data_byte &lt;= 8'd0;&#xa;&#x9;else if(bps_cnt == 8'd159)begin&#xa;&#x9;&#x9;data_byte[0] &lt;= data_byte_pre[0][2];&#xa;&#x9;&#x9;data_byte[1] &lt;= data_byte_pre[1][2];&#xa;&#x9;&#x9;data_byte[2] &lt;= data_byte_pre[2][2];&#xa;&#x9;&#x9;data_byte[3] &lt;= data_byte_pre[3][2];&#xa;&#x9;&#x9;data_byte[4] &lt;= data_byte_pre[4][2];&#xa;&#x9;&#x9;data_byte[5] &lt;= data_byte_pre[5][2];&#xa;&#x9;&#x9;data_byte[6] &lt;= data_byte_pre[6][2];&#xa;&#x9;&#x9;data_byte[7] &lt;= data_byte_pre[7][2];&#xa;&#x9;end&#x9;&#xa;&#x9;&#xa;&#x9;always@(posedge clk or posedge reset)&#xa;&#x9;if(reset)&#xa;&#x9;&#x9;uart_state &lt;= 1'b0;&#xa;&#x9;else if(uart_rx_nedge)&#xa;&#x9;&#x9;uart_state &lt;= 1'b1;&#xa;&#x9;else if(rx_done || (bps_cnt == 8'd12 &amp;&amp; (START_BIT > 2)) || (bps_cnt == 8'd155 &amp;&amp; (STOP_BIT &lt; 3)))&#xa;&#x9;&#x9;uart_state &lt;= 1'b0;&#xa;&#x9;else&#xa;&#x9;&#x9;uart_state &lt;= uart_state;&#x9;&#x9;&#xa;">
 <Port Width="20" X="-0.0222222" Datatype="wire" Datasize="1" Color="#faebd7" Side="left" Parent="uart_byte_rx" Inout="input" Height="20" Y="0.15" Name="clk" Function=""/>
 <Port Width="20" X="-0.0222222" Datatype="wire" Datasize="1" Color="#00ffff" Side="left" Parent="uart_byte_rx" Inout="input" Height="20" Y="0.316667" Name="reset_n" Function=""/>
 <Port Width="20" X="-0.0222222" Datatype="wire" Datasize="3" Color="#7fffd4" Side="left" Parent="uart_byte_rx" Inout="input" Height="20" Y="0.481667" Name="baud_set" Function=""/>
 <Port Width="20" X="-0.0222222" Datatype="wire" Datasize="1" Color="#f0ffff" Side="left" Parent="uart_byte_rx" Inout="input" Height="20" Y="0.65" Name="uart_rx" Function=""/>
 <Port Width="20" X="0.977778" Datatype="reg" Datasize="8" Color="#f5f5dc" Side="right" Parent="uart_byte_rx" Inout="output" Height="20" Y="0.231667" Name="data_byte" Function=""/>
 <Port Width="20" X="0.977778" Datatype="reg" Datasize="1" Color="#ffe4c4" Side="right" Parent="uart_byte_rx" Inout="output" Height="20" Y="0.481667" Name="rx_done" Function=""/>
</Module>
