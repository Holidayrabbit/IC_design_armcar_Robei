module arm_cal_m(
	Clk,
	Rst_n,
	input_cmd,
	data_out,
	send_en_out,
	input_id);

	//---Ports declearation: generated by Robei---
	input Clk;
	input Rst_n;
	input input_cmd;
	output [79:0] data_out;
	output send_en_out;
	input [7:0] input_id;

	wire Clk;
	wire Rst_n;
	wire input_cmd;
	reg [79:0] data_out;
	reg send_en_out;
	wire [7:0] input_id;

	//----Code starts here: integrated by Robei-----
	parameter DATA_WIDTH = 80;
	parameter fill_data = 8'h55;
	parameter delta_angle_low = 8'h53;//每次变化角度5°
	parameter delta_angle_heigh = 8'h6;
	parameter time_low = 8'hda;//0.1s一个动作
	parameter time_heigh =8'h0; 
	reg [DATA_WIDTH-1:0] reg_out_data;
	reg [7:0] angle_low [5:0];
	reg [7:0] angle_heigh [5:0];
	reg [7:0] reg_cal;////////////////
	reg [7:0] med_angle;
	reg [7:0] in_low;
	reg [7:0] in_heigh;
	reg [7:0] reg_id;
	reg run_valid;
	integer i;
	
	localparam S0 = 0;	//等待发送请求
	localparam S1 = 1;	//计算数据发送
	localparam S2 = 2;	//等待单字节数据发送完成
	localparam S3 = 3;	//检查所有数据是否发送完成
	
	reg [1:0] state_cal;
	always @(posedge Clk or negedge Rst_n)
	begin
	if (!Rst_n)
		begin
		for (i = 0 ; i < 6; i = i + 1) begin
			angle_low[i] <= 8'h0;
			angle_heigh[i] <= 8'h0;
			end
		med_angle <= 8'h0;
		in_low <= 8'h0;
		in_heigh <= 8'h0;
		reg_id <= 8'h0;
		state_cal <= S0;
		reg_cal <= 8'h0;
		end
	else
		begin
			//计算数据
		case(state_cal)
		S0:
			begin
			send_en_out <= 1'b0;
			if(input_id != 8'h0)
				begin
				state_cal <= S1;
				reg_id <= input_id;
				end
			end
		S1:
			begin
			case(reg_id)
				8'h1:
					begin
					in_low = angle_low[0];
					in_heigh = angle_heigh[0]; 
					if (input_cmd)  //加法 ??????????阻塞or非阻塞,顺时针
						add_model(in_low,in_heigh,angle_low[0],angle_heigh[0]);
					else 
						sub_model(in_low,in_heigh,angle_low[0],angle_heigh[0]);
					in_low = angle_low[0];
					in_heigh = angle_heigh[0]; 
					end
				8'h2:
					begin
					in_low = angle_low[1];
					in_heigh = angle_heigh[1]; 
					if (input_cmd) 
						add_model(in_low,in_heigh,angle_low[1],angle_heigh[1]);
					else 
						sub_model(in_low,in_heigh,angle_low[1],angle_heigh[1]);
					in_low = angle_low[1];
					in_heigh = angle_heigh[1]; 
					end
				8'h3:
					begin
					in_low = angle_low[2];
					in_heigh = angle_heigh[2]; 
					if (input_cmd)
						add_model(in_low,in_heigh,angle_low[2],angle_heigh[2]);
					else 
						sub_model(in_low,in_heigh,angle_low[2],angle_heigh[2]);
					in_low = angle_low[2];
					in_heigh = angle_heigh[2]; 
					end
				8'h4:
					begin
					in_low = angle_low[3];
					in_heigh = angle_heigh[3]; 
					if (input_cmd) 
						add_model(in_low,in_heigh,angle_low[3],angle_heigh[3]);
					else 
						sub_model(in_low,in_heigh,angle_low[3],angle_heigh[3]);
					in_low = angle_low[3];
					in_heigh = angle_heigh[3]; 
					end
				8'h5:
					begin
					in_low = angle_low[4];
					in_heigh = angle_heigh[4]; 
					if (input_cmd)
						add_model(in_low,in_heigh,angle_low[4],angle_heigh[4]);
					else 
						sub_model(in_low,in_heigh,angle_low[4],angle_heigh[4]);
					in_low = angle_low[4];
					in_heigh = angle_heigh[4]; 
					end
				8'h6:
					begin
					in_low = angle_low[5];
					in_heigh = angle_heigh[5]; 
					if (input_cmd)
						add_model(in_low,in_heigh,angle_low[5],angle_heigh[5]);
					else 
						sub_model(in_low,in_heigh,angle_low[5],angle_heigh[5]);
					in_low = angle_low[5];
					in_heigh = angle_heigh[5]; 
					end
				default:	
						begin
						in_low <= 8'h0;
						in_heigh <= 8'h0;
						end
			endcase
			reg_cal <=  ~(input_id+8'h7+8'h1+in_heigh+in_low+time_heigh+time_low);
			state_cal <= S2 ;
			end
		S2:
			begin
			reg_out_data[79:72] <= fill_data; // 0101 0101
			reg_out_data[71:64] <= fill_data;// 0101 0101
			reg_out_data[63:56] <= reg_id;//
			reg_out_data[55:48] <= 8'b00000111;
			reg_out_data[47:40] <= 8'b00000001;
			reg_out_data[39:32] <= in_heigh;
			reg_out_data[31:24] <= in_low;
			reg_out_data[23:16] <= time_heigh;
			reg_out_data[15:8] <= time_low;
			reg_out_data[7:0] <= reg_cal;
			state_cal <= S3;
			end
		S3:
			begin
			data_out <= reg_out_data;		
			send_en_out <= 1'b1;
			state_cal <= S0;
			end
		endcase
		end 
	end
	
	reg return_valid;
	//返回接受有效信号
	always @(posedge Clk or negedge Rst_n)
	begin
	if(!Rst_n)
		return_valid <= 1'b0;
	else
		begin
			if(input_id != 8'h0)
				return_valid <= 1'b1;
		else
				return_valid <= 1'b0;
		end
	end
	
	task add_model;
		input [7:0] angle_low_tr;
		input [7:0] angle_heigh_tr;
		output [7:0] a_low;
		output [7:0] a_heigh;
		begin//加法 ??????????阻塞or非阻塞
		a_low = delta_angle_low + angle_low_tr;
		if (a_low < angle_low_tr)
			med_angle = angle_heigh_tr + 8'h1;
		a_heigh = med_angle + angle_heigh_tr;
		med_angle = 8'h0;
		end
	endtask
	
	task sub_model;
		input [7:0] angle_low_tr;
		input [7:0] angle_heigh_tr;
		output [7:0] a_low;
		output [7:0] a_heigh;
		begin
		if (delta_angle_low < angle_low_tr)
			a_low = angle_low_tr - delta_angle_low;
		else 
			begin
			a_low = 8'h0; 
			med_angle = angle_heigh_tr-8'h1;
			end
		if (med_angle < delta_angle_heigh)
			a_heigh = 8'h0;
		else
			a_heigh = med_angle - delta_angle_heigh;
		med_angle = 8'h0;
		end
	endtask 
endmodule    //arm_cal_m

