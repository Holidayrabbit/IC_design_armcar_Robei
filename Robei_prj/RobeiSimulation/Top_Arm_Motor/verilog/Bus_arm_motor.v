module Bus_arm_motor(
	Clk,
	Rst_n,
	instruction_data,
	cmd_valid,
	arm_id,
	arm_cmd,
	motor_reg_address,
	motor_cmd_data,
	motor_num_cmd,
	motor_id,
	bus_rx_done);

	//---Ports declearation: generated by Robei---
	input Clk;
	input Rst_n;
	input [7:0] instruction_data;
	output cmd_valid;
	output [7:0] arm_id;
	output arm_cmd;
	output [7:0] motor_reg_address;
	output [31:0] motor_cmd_data;
	output [7:0] motor_num_cmd;
	output [7:0] motor_id;
	input bus_rx_done;

	wire Clk;
	wire Rst_n;
	wire [7:0] instruction_data;
	reg cmd_valid;
	reg [7:0] arm_id;
	reg arm_cmd;
	reg [7:0] motor_reg_address;
	reg [31:0] motor_cmd_data;
	reg [7:0] motor_num_cmd;
	reg [7:0] motor_id;
	wire bus_rx_done;

	//----Code starts here: integrated by Robei-----
			/*
			该模块负责串口指令的解析,分别输出对机械臂和电机的指令。
			
			定义串口指令：
			帧头 0x55 和 0xA5 + 器件地址 + 功能码 + 数据（寄存器地址+有效数据） + 帧尾 0xF0   ，一共10字节
			器件地址：机械臂0x00    电机0x34
			功能码：第八位表示读或者写 低四位表示有效数据的长度
			数据：
						机械臂：XX 00 00 00 00			(XX高六位表示转动的舵机，低一位表示转动方向)	[47:40]
						电机：	XX XX XX XX XX			（第一个字节表示寄存器地址，后面四个字节表示页写数据）
			
			综上，串口指令协议的长度为 10字节，我们所需做的就是对这10字节数据进行判断。
			只要满足串口指令协议要求（即帧头 0x55+帧头 0xA5+19 字节内容+帧尾 0xF0），便代表是正确的串口指令。
			随后从指令中提取出对应的起始地址、功能码、数据，并产生 cmd 有效信号（cmd_valid），发送个机械臂或者电机驱动模块。
			
			变量解释：
			bus_rx_done（r_rx_done）来自buffer的信号，当buffer发送完毕，该信号变为1
			
			还需补充的内容：
			buffer_empty
			buffer_rd		
			*/
			
				reg [7:0] data_str [9:0];		//将从buffer收到的数据拼接成完整的串口帧
	
	
				always@(posedge Clk) begin
	/*
					if(buffer_empty)			//如果buffer空了就读取无效
						begin
						cmd_valid <= #1 0;
						end
	*/
	
					if(bus_rx_done)
						begin
						//buffer_rd <=  0;
						
						data_str[9] <= #1 instruction_data;
						data_str[8] <= #1 data_str[9];
						data_str[7] <= #1 data_str[8];           
						data_str[6] <= #1 data_str[7];
						data_str[5] <= #1 data_str[6];
						data_str[4] <= #1 data_str[5];
						data_str[3] <= #1 data_str[4];
						data_str[2] <= #1 data_str[3];
						data_str[1] <= #1 data_str[2];
						data_str[0] <= #1 data_str[1];
						
						//buffer_rd <=  1;	//读取完一个字节就申请再读一个字节
					end
				end		
			
				reg r_rx_done;
	
			    always@(posedge Clk) begin
			//	if(buffer_empty)		cmd_valid <= #1 0;	//如果buffer空了就读取无效						    
				r_rx_done <= bus_rx_done;
				end
			    
			    always@(posedge Clk or negedge Rst_n)	//复位全部置为0
			    if(!Rst_n) 
					begin
			//		buffer_rd <=  0;	//初始时刻，请求读取
			        motor_reg_address <= #1 0;
					arm_id <= #1 0;
					arm_cmd <= #1 0;
					motor_cmd_data<= #1 0;
			        cmd_valid <= #1 0;
			        motor_num_cmd <= #1 0;
					
					
					end 
					
				else if(r_rx_done)
					begin			//串口数据包全部收到了，开始解析命令
						if((data_str[0] == 8'h55) && (data_str[1] == 8'hA5) && (data_str[9] == 8'hF0))
							begin
								if(data_str[2] == 8'h00)		//表示操作机械臂
									begin
									arm_id <= #1 data_str[4][7:5];		//第五个字节高三位
									arm_cmd <= #1 data_str[4][0];
									motor_id <= 0;
									motor_reg_address <= 0;  //第五个字节
									motor_cmd_data<= 0;
									motor_num_cmd <= 0;
									cmd_valid <= #1 1;
									end
								else if(data_str[2] == 8'h34)	//表示操作电机
									begin
									arm_id<=0;
									arm_cmd <= 0;								
									motor_id <= #1 8'h34;
									motor_reg_address <= #1 data_str[4];  //第五个字节
									motor_cmd_data<= #1 {data_str[5],data_str[6],data_str[7],data_str[8]};
									motor_num_cmd <= #1 data_str[3];
									cmd_valid <= #1 1;
									end
								else 
									begin
	
									arm_id<=0;
									arm_cmd <= 0;
									motor_id <= 0;
									motor_reg_address <= 0;  //第五个字节
									motor_cmd_data<= 0;
									motor_num_cmd <= 0;
										cmd_valid <= #1 0;							
									
									end
							end
					end
				else	cmd_valid <= #1 0;     
endmodule    //Bus_arm_motor

