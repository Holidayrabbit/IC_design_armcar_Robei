module i2c_control_motor_plus(
	Clk,
	Rst_n,
	wrreg_req,
	rdreg_req,
	addr,
	wrdata,
	device_id,
	rddata,
	RW_Done,
	ack,
	i2c_sclk,
	i2c_sdat,
	len,
	MOTOR_EN);

	//---Ports declearation: generated by Robei---
	input Clk;
	input Rst_n;
	input wrreg_req;
	input rdreg_req;
	input [7:0] addr;
	input [31:0] wrdata;
	input [7:0] device_id;
	output [7:0] rddata;
	output RW_Done;
	output ack;
	output i2c_sclk;
	inout i2c_sdat;
	input [3:0] len;
	input MOTOR_EN;

	wire Clk;
	wire Rst_n;
	wire wrreg_req;
	wire rdreg_req;
	wire [7:0] addr;
	wire [31:0] wrdata;
	wire [7:0] device_id;
	reg [7:0] rddata;
	reg RW_Done;
	reg ack;
	wire i2c_sclk;
	wire i2c_sdat;
	wire [3:0] len;
	wire MOTOR_EN;

	//----Code starts here: integrated by Robei-----
			/*
			Clk I 模块工作时钟， 50M 时钟
			Rst_n I 模块复位信号
			wrreg_req I 写请求信号
			rdreg_req I 读请求信号
			addr I 16 位地址输入
			addr_mode I 输入地址模式， 0： 8 位的地址， 1： 16 位地址
			
			//每写入一次数据就会跳转到等待读完成状态，同时在这个状态里面会根据 addr_mode 来
			//确定写的是 8 位地址，还是 16 位的地址，从而来控制 cnt 的值，后面回到读寄存器状态（ RD_REG）
			//里面的时候就可以选择性跳过发送高 8 位全 0 来代替的地址了。
			
			wrdata I 总线发送的 8 位数据
			rddata O 总线收到的 8 位数据
			device_id I i2c 器件的 ID
			RW_Done O 读/写完成标志
			ack O 从机是否应答标志
			i2c_sclk O i2c 时钟总线
			i2c_sdat I /O i2c 数据总线
			
			*/
				reg [5:0]Cmd;
				reg [7:0]Tx_DATA;
				wire Trans_Done;
				wire ack_o;
				reg Go;
				
				
				wire [7:0] reg_addr;
				
				assign reg_addr = addr[7:0];
	
				
				wire [7:0]Rx_DATA;
				
				localparam 
					WR   = 6'b000001,   //写请求
					STA  = 6'b000010,   //起始位请求
					RD   = 6'b000100,   //读请求
					STO  = 6'b001000,   //停止位请求
					ACK  = 6'b010000,   //应答位请求
					NACK = 6'b100000;   //无应答请求
				
			
				
				reg [6:0]state;
				reg [7:0]cnt;
				
				localparam
					IDLE         = 7'b0000001,   //空闲状态
					WR_REG       = 7'b0000010,   //写寄存器状态
					WAIT_WR_DONE = 7'b0000100,   //等待写寄存器完成状态
					WR_REG_DONE  = 7'b0001000,   //写寄存器完成状态
					RD_REG       = 7'b0010000,   //读寄存器状态
					WAIT_RD_DONE = 7'b0100000,   //等待读寄存器完成状态
					RD_REG_DONE  = 7'b1000000;   //读寄存器完成状态
				
				always@(posedge Clk or negedge Rst_n)
				if(!Rst_n)begin
					Cmd <= 6'd0;
					Tx_DATA <= 8'd0;
					Go <= 1'b0;
					rddata <= 0;
					state <= IDLE;
					ack <= 0;
				end
				else begin
					case(state)
						IDLE:
							begin
								cnt <= 0;
								ack <= 0;
								RW_Done <= 1'b0;					
								if(wrreg_req&&MOTOR_EN)
									state <= WR_REG;
								else if(rdreg_req&&MOTOR_EN)
									state <= RD_REG;
								else
									state <= IDLE;
							end
						
						WR_REG:
							begin
								state <= WAIT_WR_DONE;
								case(cnt)
									0:write_byte(WR | STA, device_id);
									1:write_byte(WR, reg_addr[7:0]);
									2:write_byte(WR, wrdata[31:24]);
									3:write_byte(WR, wrdata[23:16]);
									4:write_byte(WR, wrdata[15:8]);
									5:write_byte(WR | STO, wrdata[7:0]);
									
									//只传1位数据
									6:write_byte(WR | STO, wrdata[7:0]);
									
									default:;
								endcase
							end
						
						WAIT_WR_DONE:
							begin
								Go <= 1'b0; 
								if(Trans_Done)begin
									ack <= ack | ack_o;
									case(cnt)
										0: begin cnt <= 1; state <= WR_REG;end
										1: begin 
												if( len==4'd1) 
													begin cnt <= 6; state <= WR_REG; end			//如果要写的数据只有
												else if( len==4'd4)											//那么跳到6，写低8位数			
													begin cnt <= 2; state <= WR_REG; end
												
													
											end	
										2: begin cnt <= 3; state <= WR_REG; end									
										3: begin cnt <= 4; state <= WR_REG;end
										4: begin cnt <= 5; state <= WR_REG;end
										5: begin state <= WR_REG_DONE;end
										6: begin state <= WR_REG_DONE;end
										
										default:state <= IDLE;
									endcase
								end
							end
						
						WR_REG_DONE:
							begin
								RW_Done <= 1'b1;
								state <= IDLE;
							end
							
						RD_REG:
							begin
								state <= WAIT_RD_DONE;
								case(cnt)
									0:write_byte(WR | STA, device_id);
									1:write_byte(WR, reg_addr[15:8]);
									2:write_byte(WR, reg_addr[7:0]);
									3:write_byte(WR | STA, device_id | 8'd1);
									4:read_byte(RD | NACK | STO);
									default:;
								endcase
							end
							
						WAIT_RD_DONE:
							begin
								Go <= 1'b0; 
								if(Trans_Done)begin
									if(cnt <= 3)
										ack <= ack | ack_o;
									case(cnt)
										0: begin cnt <= 1; state <= RD_REG;end
										1: 
											begin 
												state <= RD_REG;
	
													cnt <= 3;
											end
												
										2: begin
												cnt <= 3;
												state <= RD_REG;
											end
										3:begin
												cnt <= 4;
												state <= RD_REG;
											end
										4:state <= RD_REG_DONE;
										default:state <= IDLE;
									endcase
								end
							end
							
						RD_REG_DONE:
							begin
								RW_Done <= 1'b1;
								rddata <= Rx_DATA;
								state <= IDLE;				
							end
						default:state <= IDLE;
					endcase
				end
				
				task read_byte;
					input [5:0]Ctrl_Cmd;
					begin
						Cmd <= Ctrl_Cmd;
						Go <= 1'b1; 
					end
				endtask
				
				task write_byte;
					input [5:0]Ctrl_Cmd;
					input [7:0]Wr_Byte_Data;
					begin
						Cmd <= Ctrl_Cmd;
						Tx_DATA <= Wr_Byte_Data;
						Go <= 1'b1; 
					end
				endtask
	//---Module instantiation---
	i2c_bit_shifter i2c_bit_shifter1(
		.Clk(Clk),
		.Rst_n(Rst_n),
		.Cmd(Cmd),
		.Go(Go),
		.Tx_DATA(Tx_DATA),
		.Rx_DATA(Rx_DATA),
		.Trans_Done(Trans_Done),
		.ack_o(ack_o),
		.i2c_sclk(i2c_sclk),
		.i2c_sdat(i2c_sdat));

endmodule    //i2c_control_motor_plus

