<!DOCTYPE Robei>
<Module File="Current/TFT_top.model" Name="TFT_top" Type="module" Code="&#xa;&#xa;&#xa;" Width="900" Y="0" Height="600" Include="" X="0" Class="module" Parent="0" Color="#d3d3d3" Parameters="" Comment="">
 <Module File="Current/TFT_driver.model" Name="TFT_driver3" Type="model" Code="reg res;                   &#xa;reg blk;                  &#xa;reg dcx ; //data/command control, low is command and high is data.                 &#xa;reg sda ;                  &#xa;reg [2:0] CLK_cnt;          &#xa;&#xa;assign CLK = (CLK_cnt &lt;= 2) ? 1'b0 : 1'b1; //value of CLK_cnt:0~5, system clock is divided over 6 times.&#xa;assign MOSI = sda;     // master send data&#xa;assign RES = res;       //reset signal&#xa;assign DC = dcx;        // data and command control, use for choose send data or command.&#xa;assign BLK = blk;       //Backlight control, on by default, low level off.&#xa;assign CS = 1'b0;&#xa;parameter CMD  = 0;&#xa;parameter DATA = 1;&#xa;&#xa;&#xa;reg [6:0] delay_cnt = 0;            //for delay&#xa;reg [6:0] DELAY_TIME_SET;   //delay time: 100ms&#xa;&#xa;//-----------------------generate 1ms clk--------------------------&#xa;reg [15:0] clk_1ms_cnt = 0;&#xa;always@(posedge clk)&#xa;    if(clk_1ms_cnt >= 33_333) //value: 0~33_333, use for 1ms clk.&#xa;        clk_1ms_cnt &lt;= 16'd0;&#xa;    else&#xa;        clk_1ms_cnt &lt;= clk_1ms_cnt + 1'b1;&#xa;    &#xa;wire clk_1ms;         &#xa;assign clk_1ms = clk_1ms_cnt == 1;&#xa;&#xa;//---------------------main state define---------------------&#xa;parameter  IDLE      = 7'b0000001;          //idle&#xa;parameter  RESET     = 7'b0000010;        //reset&#xa;parameter  DELAY     = 7'b0000100;        //delay&#xa;parameter  RESET_SET = 7'b0001000;    //stop reset&#xa;parameter  BLK_SET   = 7'b0010000;       //backlight control&#xa;parameter  INIT      = 7'b0100000;            //data transfer to spi display screen.&#xa;parameter  DISPLAY   = 7'b1000000;       //display&#xa;(* mark_debug=1 *)reg [6:0] main_state,next_main_state;  &#xa;&#xa;//----------------------------spi state--------------------------&#xa;parameter  SPI_IDLE  = 5'b00001;           //spi idle&#xa;parameter  SPI_START = 5'b00010;         //spi start&#xa;parameter  SPI_SEND  = 5'b00100;          //transfer data&#xa;parameter  SPI_WAIT  = 5'b01000;           //wait&#xa;parameter  SPI_STOP  = 5'b10000;          //stop&#xa;(* mark_debug=1 *)reg [4:0] spi_state,next_spi_state;     &#xa;&#xa;reg init_done;          //flag of spi to stop, if init_done is '1', the main state changes from INIT to DISPLAY.&#xa;reg color;               //controls whether the SPI transmits data or commands.&#xa;&#xa;wire rom_en;&#xa;assign rom_en = color;&#xa;assign clka = clk &amp;&amp; rom_en;&#xa;assign ena = 1'b1;&#xa;&#xa;//-------------------the first main state----------------------&#xa;always@(posedge clk or negedge rstn)&#xa;    if(!rstn)&#xa;        main_state &lt;= IDLE;&#xa;    else&#xa;        main_state &lt;= next_main_state;&#xa;&#xa;//------------------the second main state------------------&#xa;always@(*)&#xa;    begin&#xa;        case(main_state)&#xa;            IDLE : begin&#xa;                    next_main_state = RESET;&#xa;                end&#xa;            RESET : begin&#xa;                    next_main_state = DELAY;&#xa;                end&#xa;            DELAY : begin&#xa;                    if(delay_cnt == DELAY_TIME_SET)&#xa;                        next_main_state = (res == 0) ?  RESET_SET : (blk == 0) ? BLK_SET : INIT;&#xa;                    else&#xa;                        next_main_state = DELAY;&#xa;                end&#xa;            RESET_SET : begin&#xa;                    next_main_state = DELAY;&#xa;                end&#xa;            BLK_SET : begin&#xa;                    next_main_state = DELAY;&#xa;                end&#xa;            INIT : begin&#xa;                    if(init_done) //flag of spi to stop.&#xa;                        next_main_state = DISPLAY;&#xa;                    else &#xa;                        next_main_state = INIT;&#xa;                end&#xa;            DISPLAY : begin&#xa;                        next_main_state = DISPLAY;&#xa;                    end&#xa;            default : begin&#xa;                        next_main_state =  IDLE;&#xa;                    end&#xa;        endcase&#xa;    end&#xa;&#xa;//---------------------the third main state----------------------&#xa;always@(posedge clk or negedge rstn)&#xa;    if(!rstn)&#xa;        begin&#xa;           res &lt;= 1'b1;&#xa;           blk &lt;= 1'b0;&#xa;           init_done &lt;= 1'b0;&#xa;           color &lt;= 1'b0;&#xa;           delay_cnt &lt;= 7'd0;&#xa;        end&#xa;    else begin&#xa;        case(main_state)&#xa;            IDLE : begin&#xa;                    res &lt;= 1'b1;&#xa;                    blk &lt;= 1'b0;&#xa;                    init_done &lt;= 1'b0;&#xa;                    color &lt;= 1'b0;&#xa;                    delay_cnt &lt;= 7'd0;&#xa;                end &#xa;            RESET : begin&#xa;                    res &lt;= 1'b0;&#xa;                    delay_cnt &lt;= 7'd0;&#xa;                    DELAY_TIME_SET &lt;= 7'd100; //delay 100ms&#xa;                    //DELAY_TIME_SET &lt;= 7'd1;   //for test  1ms&#xa;                    end&#xa;            DELAY : begin&#xa;                    if(clk_1ms) begin&#xa;                        if(delay_cnt == DELAY_TIME_SET)&#xa;                            delay_cnt &lt;= 7'd0;&#xa;                        else&#xa;                            delay_cnt &lt;= delay_cnt + 1'b1;&#xa;                    end&#xa;                    else&#xa;                        delay_cnt &lt;= delay_cnt;&#xa;                    end&#xa;            RESET_SET : begin&#xa;                        delay_cnt &lt;= 7'd0;&#xa;                        res &lt;= 1'b1;&#xa;                        DELAY_TIME_SET &lt;= 7'd100;&#xa;                        //DELAY_TIME_SET &lt;= 7'd1; //for test  1ms&#xa;                        end&#xa;            BLK_SET : begin&#xa;                        blk &lt;= 1'b1;&#xa;                        delay_cnt &lt;= 7'd0;&#xa;                        DELAY_TIME_SET &lt;= 7'd100;&#xa;                        //DELAY_TIME_SET &lt;= 7'd1; //for test  1ms&#xa;                    end&#xa;            INIT : begin&#xa;                        delay_cnt &lt;= 7'd0;&#xa;                        if(spi_state == SPI_STOP)begin&#xa;                            color &lt;= 1'b1;&#xa;                            init_done &lt;= 1'b1;end&#xa;                        else&#xa;                            init_done &lt;= 1'b0;&#xa;                    end&#xa;            DISPLAY : begin&#xa;                            delay_cnt &lt;= 7'd0;&#xa;                            color &lt;= 1'b1;&#xa;                        end&#xa;            default :;&#xa;            endcase&#xa;            end&#xa;&#xa;//-----------------the first child state-----------------&#xa;always@(posedge clk or negedge rstn)&#xa;    if(!rstn)&#xa;        spi_state &lt;= SPI_IDLE;&#xa;    else begin&#xa;        case(main_state)&#xa;        INIT : begin&#xa;            spi_state &lt;= next_spi_state;&#xa;            end&#xa;        DISPLAY : begin&#xa;            spi_state &lt;= next_spi_state;&#xa;            end&#xa;        default : begin&#xa;            spi_state &lt;= SPI_IDLE;&#xa;            end&#xa;        endcase&#xa;    end&#xa;&#xa;(* mark_debug=1 *)reg [18:0] byte_addr;&#xa;(* mark_debug=1 *)reg [2:0] bit_cnt;         &#xa;(* mark_debug=1 *)reg [8:0] data_byte_init;  &#xa;&#xa;reg [6:0] wait_cnt = 0;     &#xa;reg [6:0] delay_time;      &#xa;&#xa;assign addr = byte_addr;&#xa;&#xa;//---------------------the second child state---------------------&#xa;always@(*)&#xa;    case(spi_state)&#xa;        SPI_IDLE : begin&#xa;                next_spi_state = SPI_START;&#xa;            end&#xa;        SPI_START:begin&#xa;                next_spi_state = SPI_SEND;&#xa;            end&#xa;        SPI_SEND :begin&#xa;                if(color == 0) begin&#xa;                        if(byte_addr == 77 &amp;&amp; bit_cnt == 7 &amp;&amp; CLK_cnt == 5)&#xa;                            next_spi_state = SPI_STOP;&#xa;                        else    begin&#xa;                            if(bit_cnt == 7 &amp;&amp; CLK_cnt == 5)&#xa;                                next_spi_state = SPI_WAIT;&#xa;                            else&#xa;                            next_spi_state = SPI_SEND;&#xa;                            end&#xa;                end&#xa;                else begin&#xa;                    if(byte_addr == 460800 &amp;&amp; bit_cnt == 7 &amp;&amp; CLK_cnt == 5)&#xa;                            next_spi_state = SPI_STOP;&#xa;                    else    begin&#xa;                                if(bit_cnt == 7 &amp;&amp; CLK_cnt == 5)&#xa;                                    next_spi_state = SPI_WAIT;&#xa;                                else&#xa;                                    next_spi_state = SPI_SEND;&#xa;                            end&#xa;                   &#xa;                    &#xa;                    end&#xa;            end&#xa;        SPI_WAIT :begin&#xa;                if(wait_cnt == delay_time)&#xa;                    next_spi_state = SPI_SEND;&#xa;                else&#xa;                    next_spi_state = SPI_WAIT;&#xa;            end&#xa;        SPI_STOP :begin&#xa;                next_spi_state = (main_state == INIT ) ? SPI_IDLE : SPI_STOP;&#xa;            end&#xa;        default :begin&#xa;                next_spi_state = SPI_IDLE;&#xa;            end&#xa;    endcase&#xa;&#xa;//---------------------------the third child state--------------------------&#xa;always@(posedge clk or negedge rstn)&#xa;    if(!rstn)&#xa;        begin&#xa;            CLK_cnt &lt;= 3'd0;&#xa;            byte_addr &lt;= 19'd0;&#xa;            bit_cnt &lt;= 3'd7;&#xa;            dcx &lt;= 1'b0;&#xa;            sda &lt;= 1'b1;&#xa;            wait_cnt = 0;&#xa;        end&#xa;    else begin&#xa;        case(spi_state)&#xa;            SPI_IDLE :begin&#xa;                CLK_cnt &lt;= 3'd0;&#xa;                byte_addr &lt;= 19'd0;&#xa;                dcx &lt;= 1'b0;&#xa;                sda &lt;= 1'b1; &#xa;                wait_cnt &lt;= 0;&#xa;            end&#xa;            SPI_START :begin&#xa;                dcx &lt;= color ? DATA : CMD;&#xa;                wait_cnt &lt;= 0;&#xa;                CLK_cnt &lt;= CLK_cnt + 1'b1;&#xa;                end&#xa;            SPI_SEND : begin&#xa;                wait_cnt &lt;= 0;&#xa;                if(CLK_cnt ==5)&#xa;                    CLK_cnt &lt;= 3'd0;&#xa;                else&#xa;                    CLK_cnt &lt;= CLK_cnt + 1'b1;&#xa;&#xa;        //-----------------byte_addr control---------------------&#xa;                if(bit_cnt == 7 &amp;&amp; CLK_cnt == 4)&#xa;                    if(color == 0) begin&#xa;                        if(byte_addr == 77)&#xa;                            byte_addr &lt;= 19'd0;&#xa;                        else&#xa;                            byte_addr &lt;= byte_addr + 1'b1;&#xa;                    end&#xa;                    else begin&#xa;                         if(byte_addr == 460799)&#xa;                            byte_addr &lt;= 19'd0;&#xa;                        else&#xa;                            byte_addr &lt;= byte_addr + 1'b1; &#xa;                    end&#xa;                else&#xa;                        byte_addr &lt;= byte_addr; &#xa;            //-----------------------dcx control------------------------&#xa;                if(bit_cnt == 7 &amp;&amp; CLK_cnt == 5)&#xa;                    dcx &lt;= color ? DATA : data_byte_init[8]; //dcx用于数据和指令的切换，传输图片数据的时候dcx为1，传输指令数据的时候也需为1&#xa;                else&#xa;                    dcx &lt;= dcx; //end&#xa;            //------------------------sda control----------------------------&#xa;                if(color) begin&#xa;                    if(CLK_cnt == 1)&#xa;                    begin&#xa;                    sda &lt;= pic_data[bit_cnt];&#xa;                    bit_cnt &lt;= bit_cnt - 1;&#xa;                    end&#xa;                    else&#xa;                    begin&#xa;                    sda &lt;= sda;&#xa;                    bit_cnt &lt;= bit_cnt;&#xa;                    end&#xa;                end&#xa;                else begin&#xa;                    if(CLK_cnt == 1)&#xa;                        begin&#xa;                        sda &lt;= data_byte_init[bit_cnt];&#xa;                        bit_cnt &lt;= bit_cnt - 1;&#xa;                        end&#xa;                    else&#xa;                        begin&#xa;                        sda &lt;= sda;&#xa;                        bit_cnt &lt;= bit_cnt;&#xa;                        end&#xa;                end&#xa;            end    &#xa;            SPI_WAIT :begin&#xa;                    if(clk_1ms) begin&#xa;                        if(wait_cnt >= delay_time)&#xa;                            wait_cnt &lt;= 7'd0;&#xa;                        else&#xa;                            wait_cnt &lt;= wait_cnt + 1'b1;&#xa;                        end&#xa;                    else begin&#xa;                        wait_cnt &lt;= wait_cnt;&#xa;                        end&#xa;                end&#xa;            SPI_STOP :begin&#xa;                    CLK_cnt &lt;= 3'd0;&#xa;                    byte_addr &lt;= 19'd0;&#xa;                    dcx &lt;= 1'b1;&#xa;                    sda &lt;= 1'b1; &#xa;                end&#xa;            default :;&#xa;        endcase&#xa;        end&#xa;&#xa;always@(posedge clk or negedge rstn)&#xa;    if(!rstn)&#xa;        delay_time &lt;= 7'd0;&#xa;    else if(byte_addr == 65)&#xa;        delay_time &lt;= color ? 7'd0 : 7'd120;&#xa;    else&#xa;        delay_time &lt;= 7'd0;&#xa;&#xa;&#xa;//---------------------------initial data and command----------------------------&#xa;always@(*)&#xa;    begin&#xa;    case(byte_addr)   &#xa;    0    : data_byte_init = {CMD,8'hE0}; //Positive Gamma Control&#xa;    1    : data_byte_init = {DATA,8'h00}; //This command is an empty command; it does not have any effect on ILI9486.&#xa;    2    : data_byte_init = {DATA,8'h07}; &#xa;    3    : data_byte_init = {DATA,8'h0F}; //Read Display Self-Diagnostic Result&#xa;    4    : data_byte_init = {DATA,8'h0D};&#xa;    5    : data_byte_init = {DATA,8'h1B};&#xa;    6    : data_byte_init = {DATA,8'h0A};&#xa;    7    : data_byte_init = {DATA,8'h3C};&#xa;    8    : data_byte_init = {DATA,8'h78};&#xa;    9    : data_byte_init = {DATA,8'h4A};&#xa;    10   : data_byte_init = {DATA,8'h07};&#xa;    11   : data_byte_init = {DATA,8'h0E};&#xa;&#x9;12   : data_byte_init = {DATA,8'h09};&#xa;&#x9;13   : data_byte_init = {DATA,8'h1B};&#xa;&#x9;14   : data_byte_init = {DATA,8'h1E};&#xa;    15   : data_byte_init = {DATA,8'h0F};//memory access control&#xa;    &#xa;    16   : data_byte_init = {CMD,8'hE1};&#xa;    17   : data_byte_init = {DATA,8'h00};&#xa;    18   : data_byte_init = {DATA,8'h22};&#xa;    19   : data_byte_init = {DATA,8'h24};&#xa;    20   : data_byte_init = {DATA,8'h06};&#xa;    21   : data_byte_init = {DATA,8'h12};&#xa;    22   : data_byte_init = {DATA,8'h07};&#xa;    23   : data_byte_init = {DATA,8'h36};&#xa;    24   : data_byte_init = {DATA,8'h47};&#xa;    25   : data_byte_init = {DATA,8'h47};&#xa;    26   : data_byte_init = {DATA,8'h06};&#xa;    27   : data_byte_init = {DATA,8'h0A};&#xa;    28   : data_byte_init = {DATA,8'h07};&#xa;    29   : data_byte_init = {DATA,8'h30};&#xa;    30   : data_byte_init = {DATA,8'h37};&#xa;    31   : data_byte_init = {DATA,8'h0F};&#xa;    &#xa;    32   : data_byte_init = {CMD,8'hC0};&#xa;    33   : data_byte_init = {DATA,8'h10};&#xa;    34   : data_byte_init = {DATA,8'h10};&#xa;    &#xa;    35   : data_byte_init = {CMD,8'hC1};&#xa;    36   : data_byte_init = {DATA,8'h41};&#xa;    &#xa;    37   : data_byte_init = {CMD,8'hC5};&#xa;    38   : data_byte_init = {DATA,8'h00};&#xa;    39   : data_byte_init = {DATA,8'h22};&#xa;    40   : data_byte_init = {DATA,8'h80};&#xa;    &#xa;    41   : data_byte_init = {CMD,8'h36};&#xa;    42   : data_byte_init = {DATA,8'h48};&#xa;    &#xa;    43   : data_byte_init = {CMD,8'h3A};&#xa;    44   : data_byte_init = {DATA,8'h66};&#xa;    &#xa;    45   : data_byte_init = {CMD,8'hB0};&#xa;    46   : data_byte_init = {DATA,8'h00};&#xa;    &#xa;    47   : data_byte_init = {CMD,8'hB1};&#xa;    48   : data_byte_init = {DATA,8'hB0};&#xa;    49   : data_byte_init = {CMD,8'h11};&#xa;    &#xa;    50   : data_byte_init = {CMD,8'hB4};&#xa;    51   : data_byte_init = {DATA,8'h02};&#xa;    &#xa;    52   : data_byte_init = {CMD,8'hB6};&#xa;    53   : data_byte_init = {DATA,8'h02};&#xa;    54   : data_byte_init = {DATA,8'h02};&#xa;    &#xa;    55   : data_byte_init = {CMD,8'hB7};&#xa;    56   : data_byte_init = {DATA,8'hC6};&#xa;    &#xa;    57   : data_byte_init = {CMD,8'hE9};&#xa;    58   : data_byte_init = {DATA,8'h00};&#xa;    &#xa;    59   : data_byte_init = {CMD,8'hF7};&#xa;    60   : data_byte_init = {DATA,8'hA9};&#xa;    61   : data_byte_init = {DATA,8'h51};&#xa;    62   : data_byte_init = {DATA,8'h2C};&#xa;    63   : data_byte_init = {DATA,8'h82};&#xa;    &#xa;    64   : data_byte_init = {CMD,8'h11};&#xa;//delay_ms(120);&#xa;    65   : data_byte_init = {CMD,8'h29}; //display on cmd&#xa;    66   : data_byte_init = {CMD,8'h2a};//列地址设置 0~319 &#xa;    67   : data_byte_init = {DATA,8'h00};&#xa;    68   : data_byte_init = {DATA,8'h00};&#xa;    69   : data_byte_init = {DATA,8'h01};&#xa;    70   : data_byte_init = {DATA,8'h3f};&#xa;    71   : data_byte_init = {CMD,8'h2b};//行地址设置 0~479 &#xa;    72   : data_byte_init = {DATA,8'h00};&#xa;    73   : data_byte_init = {DATA,8'h00};&#xa;    74   : data_byte_init = {DATA,8'h01};&#xa;    75   : data_byte_init = {DATA,8'hdf};&#xa;    76  : data_byte_init = {CMD,8'h2C};//储存器写 &#xa;    default : data_byte_init = {DATA,8'h00};&#xa;    endcase&#xa;    end&#xa;&#xa;&#xa;" Width="225" Y="178.482" Height="349" Include="" X="170.298" Class="TFT_driver" Parent="TFT_top" Color="#d3d3d3" Parameters="" Comment="">
  <Port Name="clk" Datasize="1" Width="20" Y="0.303725" Function="" Side="left" Height="20" X="-0.0888889" Inout="input" Connect="" Parent="TFT_driver3" Datatype="wire" Color="#ff0000"/>
  <Port Name="rstn" Datasize="1" Width="20" Y="0.469914" Function="" Side="left" Height="20" X="-0.0888889" Inout="input" Connect="" Parent="TFT_driver3" Datatype="wire" Color="#ffff00"/>
  <Port Name="pic_data" Datasize="8" Width="20" Y="0.636103" Function="" Side="left" Height="20" X="-0.0888889" Inout="input" Connect="" Parent="TFT_driver3" Datatype="wire" Color="#0000ff"/>
  <Port Name="CLK" Datasize="1" Width="20" Y="0.137536" Function="" Side="left" Height="20" X="-0.0888889" Inout="output" Connect="" Parent="TFT_driver3" Datatype="wire" Color="#008000"/>
  <Port Name="MOSI" Datasize="1" Width="20" Y="0.0802292" Function="" Side="right" Height="20" X="0.911111" Inout="output" Connect="" Parent="TFT_driver3" Datatype="wire" Color="#ffa500"/>
  <Port Name="RES" Datasize="1" Width="20" Y="0.189112" Function="" Side="right" Height="20" X="0.911111" Inout="output" Connect="" Parent="TFT_driver3" Datatype="wire" Color="#ffc0cb"/>
  <Port Name="DC" Datasize="1" Width="20" Y="0.297994" Function="" Side="right" Height="20" X="0.911111" Inout="output" Connect="" Parent="TFT_driver3" Datatype="wire" Color="#800080"/>
  <Port Name="addr" Datasize="19" Width="20" Y="0.515759" Function="" Side="right" Height="20" X="0.911111" Inout="output" Connect="" Parent="TFT_driver3" Datatype="wire" Color="#808080"/>
  <Port Name="clka" Datasize="1" Width="20" Y="0.624642" Function="" Side="right" Height="20" X="0.911111" Inout="output" Connect="" Parent="TFT_driver3" Datatype="wire" Color="#6495ed"/>
  <Port Name="ena" Datasize="1" Width="20" Y="0.733524" Function="" Side="right" Height="20" X="0.911111" Inout="output" Connect=" " Parent="TFT_driver3" Datatype="wire" Color="#deb887"/>
  <Port Name="BLK" Datasize="1" Width="20" Y="0.406877" Function="" Side="right" Height="20" X="0.911111" Inout="output" Connect="" Parent="TFT_driver3" Datatype="wire" Color="#008080"/>
 </Module>
 <Module File="Current/single_ROM2.model" Name="single_ROM22" Type="model" Code="&#x9;parameter DATA_WIDTH = 8;&#xa;&#x9;parameter ADDR_DEPTH = 500000;&#xa;&#x9;&#xa;&#x9;    parameter   DELAY   = 1     ;//read data output delay&#xa;&#x9;&#xa;&#x9;reg [DATA_WIDTH-1:0] rom[ADDR_DEPTH-1:0];&#x9;&#x9;&#x9;//&#x9;&#x9;&#x9;2**ADDR_WIDTH=2^(ADDR_WIDTH)&#xa;&#x9;&#xa;&#x9;initial &#xa;&#x9;begin&#xa;&#x9;    $readmemh(&quot;E:/CodeFile/Fusai/BAJIAOBAN/Top_Final/vivado/Picture_Data/output2.txt&quot;, rom);   //读取16进制数据&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;//读取2进制数据&#xa;&#x9;end&#xa;&#x9;&#xa;&#x9;reg [DATA_WIDTH-1:0] buffer [0:DELAY];&#xa;&#x9;&#xa;&#x9;always @(posedge clk)&#xa;&#x9;    begin&#xa;&#x9;&#xa;&#x9; //读操作条件，当RDEnable为1且CS为1时，将Addr指定的内存单元中的数据读出并暂存在Data_read中&#xa;&#x9;   q &lt;= rom[addr];&#xa;&#x9; //其他条件，当CS为0或RDEnable为不确定值时，将Data_read置为高阻抗状态&#xa;&#x9;    end&#xa;&#x9;&#xa;&#x9;&#xa;&#x9;always@(posedge clk) begin&#xa;&#x9;&#xa;&#x9;        buffer[1] &lt;= buffer[0];&#xa;&#x9;&#xa;&#x9;end&#xa;&#x9;&#xa;&#x9;//assign q = buffer[0];" Width="221" Y="218.307" Height="226" Include="" X="495.349" Class="single_ROM2" Parent="TFT_top" Color="#d3d3d3" Parameters="" Comment="">
  <Port Name="clk" Datasize="1" Width="20" Y="0.20354" Function="" Side="left" Height="20" X="-0.0904977" Inout="input" Connect="" Parent="single_ROM22" Datatype="wire" Color="#faebd7"/>
  <Port Name="addr" Datasize="19" Width="20" Y="0.451327" Function="" Side="left" Height="20" X="-0.0904977" Inout="input" Connect="" Parent="single_ROM22" Datatype="wire" Color="#00ffff"/>
  <Port Name="q" Datasize="8" Width="20" Y="0.287611" Function="" Side="right" Height="20" X="0.909502" Inout="output" Connect="" Parent="single_ROM22" Datatype="reg" Color="#7fffd4"/>
 </Module>
 <Port Name="clk" Datasize="1" Width="20" Y="0.233333" Function="" Side="left" Height="20" X="-0.0222222" Inout="input" Parent="TFT_top" Datatype="wire" Color="#ff0000"/>
 <Port Name="rstn" Datasize="1" Width="20" Y="0.483333" Function="" Side="left" Height="20" X="-0.0222222" Inout="input" Parent="TFT_top" Datatype="wire" Color="#ffff00"/>
 <Port Name="CLK" Datasize="1" Width="20" Y="0.125" Function="" Side="right" Height="20" X="0.977778" Inout="output" Parent="TFT_top" Datatype="wire" Color="#008000"/>
 <Port Name="MOSI" Datasize="1" Width="20" Y="0.266667" Function="" Side="right" Height="20" X="0.977778" Inout="output" Parent="TFT_top" Datatype="wire" Color="#ffa500"/>
 <Port Name="RES" Datasize="1" Width="20" Y="0.408333" Function="" Side="right" Height="20" X="0.977778" Inout="output" Parent="TFT_top" Datatype="wire" Color="#ffc0cb"/>
 <Port Name="DC" Datasize="1" Width="20" Y="0.55" Function="" Side="right" Height="20" X="0.977778" Inout="output" Parent="TFT_top" Datatype="wire" Color="#800080"/>
 <Port Name="BLK" Datasize="1" Width="20" Y="0.691667" Function="" Side="right" Height="20" X="0.977778" Inout="output" Parent="TFT_top" Datatype="wire" Color="#008080"/>
 <Wire Name="TFT_top_clk" Datasize="1" To="TFT_top#TFT_driver3>clk" From="TFT_top>clk" Parent="TFT_top" Datatype="wire"/>
 <Wire Name="TFT_top_rstn" Datasize="1" To="TFT_top#TFT_driver3>rstn" From="TFT_top>rstn" Parent="TFT_top" Datatype="wire"/>
 <Wire Name="TFT_driver3_CLK" Datasize="1" To="TFT_top>CLK" From="TFT_top#TFT_driver3>CLK" Parent="TFT_top" Datatype="wire"/>
 <Wire Name="TFT_driver3_MOSI" Datasize="1" To="TFT_top>MOSI" From="TFT_top#TFT_driver3>MOSI" Parent="TFT_top" Datatype="wire"/>
 <Wire Name="TFT_driver3_RES" Datasize="1" To="TFT_top>RES" From="TFT_top#TFT_driver3>RES" Parent="TFT_top" Datatype="wire"/>
 <Wire Name="TFT_driver3_DC" Datasize="1" To="TFT_top>DC" From="TFT_top#TFT_driver3>DC" Parent="TFT_top" Datatype="wire"/>
 <Wire Name="TFT_driver3_BLK" Datasize="1" To="TFT_top>BLK" From="TFT_top#TFT_driver3>BLK" Parent="TFT_top" Datatype="wire"/>
 <Wire Name="TFT_driver3_addr" Datasize="19" To="TFT_top#single_ROM22>addr" From="TFT_top#TFT_driver3>addr" Parent="TFT_top" Datatype="wire"/>
 <Wire Name="TFT_driver3_clka" Datasize="1" To="TFT_top#single_ROM22>clk" From="TFT_top#TFT_driver3>clka" Parent="TFT_top" Datatype="wire"/>
 <Wire Name="single_ROM22_q" Datasize="8" To="TFT_top#TFT_driver3>pic_data" From="TFT_top#single_ROM22>q" Parent="TFT_top" Datatype="wire"/>
</Module>
