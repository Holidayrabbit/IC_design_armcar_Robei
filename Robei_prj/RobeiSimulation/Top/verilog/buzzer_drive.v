module buzzer_drive(
	Clk,
	Rst_n,
	Beeee,
	BUZZER_EN);

	//---Ports declearation: generated by Robei---
	input Clk;
	input Rst_n;
	output Beeee;
	input BUZZER_EN;

	wire Clk;
	wire Rst_n;
	wire Beeee;
	wire BUZZER_EN;

	//----Code starts here: integrated by Robei-----
	
		
			reg [31:0]counter_arr;    //预重装值寄存器
			wire [31:0]counter_ccr;    //输出比较值
		
			reg [24:0]t500ms_dly_cnt; //500ms延时计数器
			reg [2:0]pitch_num;      //音调编号
		
			parameter T500ms_MAX_CNT  = 25'd16_666_666;
		
			localparam
				D1  = 170068, //D调音1 
				D2  = 151515, //D调音2 
				D3  = 142857, //D调音3 
				D4  = 127227, //D调音4 
				D5  = 113379, //D调音5 
				D6  = 101010, //D调音6 
				D7  = 89928 ; //D调音7
		
		  //输出比较值为预重装值一半
				assign counter_ccr = counter_arr >> 1;
		
		
		    
			//500ms延时计数器计数
			always@(posedge Clk or posedge Rst_n)
			if(!Rst_n)
				t500ms_dly_cnt <= 1'd0;
			else if(t500ms_dly_cnt == T500ms_MAX_CNT - 1'b1)
				t500ms_dly_cnt <= 1'd0;
			else
				t500ms_dly_cnt <= t500ms_dly_cnt + 1'b1;
		    
			//每500ms切换一次音调
			always@(posedge Clk or posedge Rst_n)
			if(!Rst_n)
				pitch_num <= 3'd0;
			else if(t500ms_dly_cnt == T500ms_MAX_CNT - 1'b1)
		    pitch_num <= pitch_num + 1'd1;
			else
				pitch_num <= pitch_num;
		        
		  //根据音调编号给预重装值给相应的值
			always@(posedge Clk or posedge Rst_n)
			if(!Rst_n)
				counter_arr  = 32'd1;
			else
			begin
				case(pitch_num)
					0 :counter_arr  = 32'd1;
					1 :counter_arr  = D1;
					2 :counter_arr  = D2;
					3 :counter_arr  = D3;
					4 :counter_arr  = D4;
					5 :counter_arr  = D5;
					6 :counter_arr  = D6;
					7 :counter_arr  = D7;
				endcase
			end
	//---Module instantiation---
	pwm_generator pwm_generator1(
		.Clk(Clk),
		.Rst_n(Rst_n),
		.pwm_gen_en(BUZZER_EN),
		.counter_arr(counter_arr),
		.counter_ccr(counter_ccr),
		.pwm_out(Beeee));

endmodule    //buzzer_drive

