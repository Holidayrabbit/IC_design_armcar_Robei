module TFT_driver(
	clk,
	rstn,
	pic_data,
	CLK,
	MOSI,
	RES,
	DC,
	addr,
	clka,
	ena,
	BLK);

	//---Ports declearation: generated by Robei---
	input clk;
	input rstn;
	input [7:0] pic_data;
	output CLK;
	output MOSI;
	output RES;
	output DC;
	output [18:0] addr;
	output clka;
	output ena;
	output BLK;

	wire clk;
	wire rstn;
	wire [7:0] pic_data;
	wire CLK;
	wire MOSI;
	wire RES;
	wire DC;
	wire [18:0] addr;
	wire clka;
	wire ena;
	wire BLK;

	//----Code starts here: integrated by Robei-----
	
		reg res;                    //(*mark_debug = "true"*)
		reg blk;                    //(*mark_debug = "true"*)
		reg dcx ;                   //(*mark_debug = "true"*)
		reg sda ;                   //(*mark_debug = "true"*)
		reg [2:0] CLK_cnt;          //(*mark_debug = "true"*)
		
		assign CLK = (CLK_cnt <= 2) ? 1'b0 : 1'b1;             //CLK_cnt的值：0~5    系统时钟6分频
		assign MOSI = sda;          // 主机发送数据
		assign RES = res;           //复位信号
		assign DC = dcx;            // 数据或命令选择      用于区分写入显示屏的是数据还是命令
		assign BLK = blk;           //背光控制，默认开启，低电平关闭（不亮）空闲时刻
	//	assign CS = 1'b0;
		parameter CMD  = 0;
		parameter DATA = 1;
		
		
		reg [6:0] delay_cnt = 0;           //用于延时
		reg [6:0] DELAY_TIME_SET;          //延时时间：  100ms
		//generate 1ms clk
		reg [15:0] clk_1ms_cnt = 0;
		always@(posedge clk)
		    if(clk_1ms_cnt >= 33_333)            //值：  0~33_333: 用于计数1ms
		        clk_1ms_cnt <= 16'd0;
		    else
		        clk_1ms_cnt <= clk_1ms_cnt + 1'b1;
		    
		wire clk_1ms;           //(*mark_debug = "true"*)
		
		assign clk_1ms = clk_1ms_cnt == 1;
		//#####################################main state machine\        主状态
		
		
		parameter  IDLE      = 7'b0000001;          //空闲
		parameter  RESET     = 7'b0000010;          //复位
		parameter  DELAY     = 7'b0000100;          //延时
		parameter  RESET_SET = 7'b0001000;          //复位？
		parameter  BLK_SET   = 7'b0010000;          //背光控制
		parameter  INIT      = 7'b0100000;          //数据输入SPI显示屏
		parameter  DISPLAY   = 7'b1000000;          //显示
		(* mark_debug=1 *)reg [6:0] main_state,next_main_state;       //(*mark_debug = "true"*)
		
		parameter  SPI_IDLE  = 5'b00001;           //SPI空闲      SPI状态
		parameter  SPI_START = 5'b00010;           //SPI开始
		parameter  SPI_SEND  = 5'b00100;           //传数
		parameter  SPI_WAIT  = 5'b01000;           //等待
		parameter  SPI_STOP  = 5'b10000;           //停止
		(* mark_debug=1 *)reg [4:0] spi_state,next_spi_state;     //(*mark_debug = "true"*)
		
		reg init_done;          //(*mark_debug = "true"*)       //SPI进入到停止状态的标志；若为1：主状态由INIT转为DISPLAY
		reg color;              //(*mark_debug = "true"*)       //INIT（SPI进入到停止状态）、DISPLAY为1，其他状态为0：  SPI_SEND到下一状态的判断标志；控制SPI传输的是数据还是命令（对应数据还是命令地址改变）；
		//
		wire rom_en;
		assign rom_en = color;
		assign clka = clk && rom_en;
		assign ena = 1'b1;
		
		always@(posedge clk or negedge rstn)
		    if(!rstn)
		        main_state <= IDLE;
		    else
		        main_state <= next_main_state;
		
		always@(*)
		    begin
		        case(main_state)
		            IDLE : begin
		                    next_main_state = RESET;
		                end
		            RESET : begin
		                    next_main_state = DELAY;
		                end
		            DELAY : begin
		                    if(delay_cnt == DELAY_TIME_SET)
		                        next_main_state = (res == 0) ?  RESET_SET : (blk == 0) ? BLK_SET : INIT;
		                    else
		                        next_main_state = DELAY;
		                end
		            RESET_SET : begin
		                    next_main_state = DELAY;
		                end
		            BLK_SET : begin
		                    next_main_state = DELAY;
		                end
		            INIT : begin
		                    if(init_done)
		                        next_main_state = DISPLAY;
		                    else 
		                        next_main_state = INIT;
		                end
		            DISPLAY : begin
		                        next_main_state = DISPLAY;
		                    end
		            default : begin
		                        next_main_state =  IDLE;
		                    end
		        endcase
		    end
		
		always@(posedge clk or negedge rstn)
		    if(!rstn)
		        begin
		           res <= 1'b1;
		           blk <= 1'b0;
		           init_done <= 1'b0;
		           color <= 1'b0;
		           delay_cnt <= 7'd0;
		        end
		    else begin
		        case(main_state)
		            IDLE : begin
		                    res <= 1'b1;
		                    blk <= 1'b0;
		                    init_done <= 1'b0;
		                    color <= 1'b0;
		                    delay_cnt <= 7'd0;
		                end 
		            RESET : begin
		                    res <= 1'b0;
		                    delay_cnt <= 7'd0;
		                    DELAY_TIME_SET <= 7'd100;//     100ms;
		                    //DELAY_TIME_SET <= 7'd1;//   for test  1ms;
		                    end
		            DELAY : begin
		                    if(clk_1ms) begin
		                        if(delay_cnt == DELAY_TIME_SET)
		                            delay_cnt <= 7'd0;
		                        else
		                            delay_cnt <= delay_cnt + 1'b1;
		                    end
		                    else
		                        delay_cnt <= delay_cnt;
		                    end
		            RESET_SET : begin
		                        delay_cnt <= 7'd0;
		                        res <= 1'b1;
		                        DELAY_TIME_SET <= 7'd100;//ms;
		                        //DELAY_TIME_SET <= 7'd1;//   for test  1ms;
		                        end
		            BLK_SET : begin
		                        blk <= 1'b1;
		                        delay_cnt <= 7'd0;
		                        DELAY_TIME_SET <= 7'd100;//ms;
		                        //DELAY_TIME_SET <= 7'd1;//   for test  1ms;
		                    end
		            INIT : begin
		                        delay_cnt <= 7'd0;
		                        if(spi_state == SPI_STOP)begin
		                            color <= 1'b1;
		                            init_done <= 1'b1;end
		                        else
		                            init_done <= 1'b0;
		                    end
		            DISPLAY : begin
		                            delay_cnt <= 7'd0;
		                            color <= 1'b1;
		                        end
		            default :;
		            endcase
		            end
		
		////////################################
		
		
		always@(posedge clk or negedge rstn)
		    if(!rstn)
		        spi_state <= SPI_IDLE;
		    else begin
		        case(main_state)
		        INIT : begin
		            spi_state <= next_spi_state;
		            end
		        DISPLAY : begin
		            spi_state <= next_spi_state;
		            end
		        default : begin
		            spi_state <= SPI_IDLE;
		            end
		        endcase
		    end
		(* mark_debug=1 *)reg [18:0] byte_addr;
		
		(* mark_debug=1 *)reg [2:0] bit_cnt;          //(*mark_debug = "true"*)
		(* mark_debug=1 *)reg [8:0] data_byte_init;   //(*mark_debug = "true"*)
		
		reg [6:0] wait_cnt = 0;     //(*mark_debug = "true"*)
		reg [6:0] delay_time;       //(*mark_debug = "true"*)
		
		
		assign addr = byte_addr;
		
		always@(*)
		    case(spi_state)
		        SPI_IDLE : begin
		                next_spi_state = SPI_START;
		            end
		        SPI_START:begin
		                next_spi_state = SPI_SEND;
		            end
		        SPI_SEND :begin
		                if(color == 0) begin
		                        if(byte_addr == 77 && bit_cnt == 7 && CLK_cnt == 5)
		                            next_spi_state = SPI_STOP;
		                        else    begin
		                            if(bit_cnt == 7 && CLK_cnt == 5)
		                                next_spi_state = SPI_WAIT;
		                            else
		                            next_spi_state = SPI_SEND;
		                            end
		                end
		                else begin
		                    if(byte_addr == 460800 && bit_cnt == 7 && CLK_cnt == 5)
		                            next_spi_state = SPI_STOP;
		                    else    begin
		                                if(bit_cnt == 7 && CLK_cnt == 5)
		                                    next_spi_state = SPI_WAIT;
		                                else
		                                    next_spi_state = SPI_SEND;
		                            end
		                   
		                    
		                    end
		            end
		        SPI_WAIT :begin
		                if(wait_cnt == delay_time)
		                    next_spi_state = SPI_SEND;
		                else
		                    next_spi_state = SPI_WAIT;
		            end
		        SPI_STOP :begin
		                next_spi_state = (main_state == INIT ) ? SPI_IDLE : SPI_STOP;
		            end
		        default :begin
		                next_spi_state = SPI_IDLE;
		            end
		    endcase
		
		always@(posedge clk or negedge rstn)
		    if(!rstn)
		        begin
		            CLK_cnt <= 3'd0;
		            byte_addr <= 19'd0;
		            bit_cnt <= 3'd7;
		            dcx <= 1'b0;
		            sda <= 1'b1;
		            wait_cnt = 0;
		        end
		    else begin
		        case(spi_state)
		            SPI_IDLE :begin
		                CLK_cnt <= 3'd0;
		                byte_addr <= 19'd0;
		                dcx <= 1'b0;
		                sda <= 1'b1; 
		                wait_cnt <= 0;
		            end
		            SPI_START :begin
		                dcx <= color ? DATA : CMD;
		                wait_cnt <= 0;
		                CLK_cnt <= CLK_cnt + 1'b1;
		                end
		            SPI_SEND : begin
		                wait_cnt <= 0;
		                if(CLK_cnt ==5)
		                    CLK_cnt <= 3'd0;
		                else
		                    CLK_cnt <= CLK_cnt + 1'b1;
		
		        //###########  byte_addr ctrl##################
		                if(bit_cnt == 7 && CLK_cnt == 4)
		                    if(color == 0) begin
		                        if(byte_addr == 77)
		                            byte_addr <= 19'd0;
		                        else
		                            byte_addr <= byte_addr + 1'b1;
		                    end
		                    else begin
		                         if(byte_addr == 460799)
		                            byte_addr <= 19'd0;
		                        else
		                            byte_addr <= byte_addr + 1'b1; 
		                    end
		                else
		                        byte_addr <= byte_addr; 
		            //##########  dcx ctrl ########################
		                if(bit_cnt == 7 && CLK_cnt == 5)
		                    dcx <= color ? DATA : data_byte_init[8];
		                else
		                    dcx <= dcx;//end
		            //#############  sda   ctrl  ######################
		                if(color) begin
		                    if(CLK_cnt == 1)
		                    begin
		                    sda <= pic_data[bit_cnt];
		                    bit_cnt <= bit_cnt - 1;
		                    end
		                    else
		                    begin
		                    sda <= sda;
		                    bit_cnt <= bit_cnt;
		                    end
		                end
		                else begin
		                    if(CLK_cnt == 1)
		                        begin
		                        sda <= data_byte_init[bit_cnt];
		                        bit_cnt <= bit_cnt - 1;
		                        end
		                    else
		                        begin
		                        sda <= sda;
		                        bit_cnt <= bit_cnt;
		                        end
		                end
		            end    
		            SPI_WAIT :begin
		                    if(clk_1ms) begin
		                        if(wait_cnt >= delay_time)
		                            wait_cnt <= 7'd0;
		                        else
		                            wait_cnt <= wait_cnt + 1'b1;
		                        end
		                    else begin
		                        wait_cnt <= wait_cnt;
		                        end
		                end
		            SPI_STOP :begin
		                    CLK_cnt <= 3'd0;
		                    byte_addr <= 19'd0;
		                    dcx <= 1'b1;
		                    sda <= 1'b1; 
		                end
		            default :;
		        endcase
		        end
		
		always@(posedge clk or negedge rstn)
		    if(!rstn)
		        delay_time <= 7'd0;
		    else if(byte_addr == 65)
		        delay_time <= color ? 7'd0 : 7'd120;
		        //delay_time <= color ? 7'd0 : 7'd1;//for test 1ms
		    //else if(byte_addr == 29)
		        //delay_time <= color ? 7'd0 : 7'd50;
		        //delay_time <= color ? 7'd0 : 7'd1;//for test 1ms
		   // else if(byte_addr == 62)
		      //  delay_time <= color ? 7'd0 : 7'd120;
		        //delay_time <= color ? 7'd0 : 7'd1;//for test 1ms
		    else
		        delay_time <= 7'd0;
		//############################ initial data and cmd ###################
		always@(*)
		    begin
		    case(byte_addr)   
		    0    : data_byte_init = {CMD,8'hE0}; //sleep out then wait 120ms
		    1    : data_byte_init = {DATA,8'h00}; 
		    2    : data_byte_init = {DATA,8'h07};
		    3    : data_byte_init = {DATA,8'h0F};
		    4    : data_byte_init = {DATA,8'h0D};
		    5    : data_byte_init = {DATA,8'h1B};
		    6    : data_byte_init = {DATA,8'h0A};
		    7    : data_byte_init = {DATA,8'h3C};
		    8    : data_byte_init = {DATA,8'h78};
		    9    : data_byte_init = {DATA,8'h4A};
		    10   : data_byte_init = {DATA,8'h07};
		    11   : data_byte_init = {DATA,8'h0E};
			12   : data_byte_init = {DATA,8'h09};
			13   : data_byte_init = {DATA,8'h1B};
			14   : data_byte_init = {DATA,8'h1E};
		    15   : data_byte_init = {DATA,8'h0F};//memory access control
		    
		    16   : data_byte_init = {CMD,8'hE1};
		    17   : data_byte_init = {DATA,8'h00};
		    18   : data_byte_init = {DATA,8'h22};
		    19   : data_byte_init = {DATA,8'h24};
		    20   : data_byte_init = {DATA,8'h06};
		    21   : data_byte_init = {DATA,8'h12};
		    22   : data_byte_init = {DATA,8'h07};
		    23   : data_byte_init = {DATA,8'h36};
		    24   : data_byte_init = {DATA,8'h47};
		    25   : data_byte_init = {DATA,8'h47};
		    26   : data_byte_init = {DATA,8'h06};
		    27   : data_byte_init = {DATA,8'h0A};
		    28   : data_byte_init = {DATA,8'h07};
		    29   : data_byte_init = {DATA,8'h30};
		    30   : data_byte_init = {DATA,8'h37};
		    31   : data_byte_init = {DATA,8'h0F};
		    
		    32   : data_byte_init = {CMD,8'hC0};
		    33   : data_byte_init = {DATA,8'h10};
		    34   : data_byte_init = {DATA,8'h10};
		    
		    35   : data_byte_init = {CMD,8'hC1};
		    36   : data_byte_init = {DATA,8'h41};
		    
		    37   : data_byte_init = {CMD,8'hC5};
		    38   : data_byte_init = {DATA,8'h00};
		    39   : data_byte_init = {DATA,8'h22};
		    40   : data_byte_init = {DATA,8'h80};
		    
		    41   : data_byte_init = {CMD,8'h36};
		    42   : data_byte_init = {DATA,8'h48};
		    
		    43   : data_byte_init = {CMD,8'h3A};
		    44   : data_byte_init = {DATA,8'h66};
		    
		    45   : data_byte_init = {CMD,8'hB0};
		    46   : data_byte_init = {DATA,8'h00};
		    
		    47   : data_byte_init = {CMD,8'hB1};
		    48   : data_byte_init = {DATA,8'hB0};
		    49   : data_byte_init = {CMD,8'h11};
		    
		    50   : data_byte_init = {CMD,8'hB4};
		    51   : data_byte_init = {DATA,8'h02};
		    
		    52   : data_byte_init = {CMD,8'hB6};
		    53   : data_byte_init = {DATA,8'h02};
		    54   : data_byte_init = {DATA,8'h02};
		    
		    55   : data_byte_init = {CMD,8'hB7};
		    56   : data_byte_init = {DATA,8'hC6};
		    
		    57   : data_byte_init = {CMD,8'hE9};
		    58   : data_byte_init = {DATA,8'h00};
		    
		    59   : data_byte_init = {CMD,8'hF7};
		    60   : data_byte_init = {DATA,8'hA9};
		    61   : data_byte_init = {DATA,8'h51};
		    62   : data_byte_init = {DATA,8'h2C};
		    63   : data_byte_init = {DATA,8'h82};
		    
		    64   : data_byte_init = {CMD,8'h11};
		//delay_ms(120);
		    65   : data_byte_init = {CMD,8'h29}; //display on cmd
		    66   : data_byte_init = {CMD,8'h2a};//列地址设置 0~319 
		    67   : data_byte_init = {DATA,8'h00};
		    68   : data_byte_init = {DATA,8'h00};
		    69   : data_byte_init = {DATA,8'h01};
		    70   : data_byte_init = {DATA,8'h3f};
		    71   : data_byte_init = {CMD,8'h2b};//行地址设置 0~479 
		    72   : data_byte_init = {DATA,8'h00};
		    73   : data_byte_init = {DATA,8'h00};
		    74   : data_byte_init = {DATA,8'h01};
		    75   : data_byte_init = {DATA,8'hdf};
		    76  : data_byte_init = {CMD,8'h2C};//储存器写 
		    default : data_byte_init = {DATA,8'h00};
		    endcase
		    end
		
		
		
	
	
	
endmodule    //TFT_driver

