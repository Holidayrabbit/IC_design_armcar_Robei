module Wheel_Instruction_Analysis(
	Clk,
	Rst_n,
	rddata,
	RW_Done,
	ack,
	address,
	cmd_data,
	num_cmd,
	motor_rddata,
	wrdata,
	wrreg_req,
	rdreg_req,
	addr,
	motor_rd_done,
	motor_wr_done,
	cmd_valid,
	data_len);

	//---Ports declearation: generated by Robei---
	input Clk;
	input Rst_n;
	input [7:0] rddata;
	input RW_Done;
	input ack;
	input [7:0] address;
	input [31:0] cmd_data;
	input [7:0] num_cmd;
	output [31:0] motor_rddata;
	output [31:0] wrdata;
	output wrreg_req;
	output rdreg_req;
	output [7:0] addr;
	output motor_rd_done;
	output motor_wr_done;
	input cmd_valid;
	output [3:0] data_len;

	wire Clk;
	wire Rst_n;
	wire [7:0] rddata;
	wire RW_Done;
	wire ack;
	wire [7:0] address;
	wire [31:0] cmd_data;
	wire [7:0] num_cmd;
	reg [31:0] motor_rddata;
	reg [31:0] wrdata;
	reg wrreg_req;
	reg rdreg_req;
	reg [7:0] addr;
	reg motor_rd_done;
	reg motor_wr_done;
	wire cmd_valid;
	reg [3:0] data_len;

	//----Code starts here: integrated by Robei-----
			/*
			Readme
			convert 模块负责指令到读写操作的转换
			1.当来自 uart_cmd 的 cmdvalid 信号有效的时候， convert 模块会根据功能码（num_cmd）判断当前的操作模式以及实际读写的数据量。
			//num_cmd[7]为0代表写操作   num_cmd[3:0]表示数据长度
			2.如果是写操作，
			则将地址和待写入数据发送给前面章节中我们设计好的 I2C 控制器。
			为了让数据能够成功被 I2C 控制器接收，需要在传输每字节数据时，产生一个写请求信
			号给 I2C 控制器。同时，因为 I2C 控制器每次只支持单个字节的收发，所以我们需要在每写
			完 1 字节数据后等待 I2C 控制器的应答信号（ack），以确保数据成功写入。
			
			3.如果是读操作，除了将地址传输给 I2C 控制器外，在读取每 1 字节数据之前，都需要产
			生一次读请求信号。在 I2C 控制器对读请求信号进行响应后才能读去这 1 字节的数据，如此
			循环，直到读取完所需的数据量，并最终输出给多字节串口发送模块。
			
			3.定义 IDLE、
			DO_WR、 WAIT_WR_DONE、 DO_RD、 WAIT_RD_DONE 五个状态。
			让 IDLE 态等待 cmdvalid 信号，判断读写操作； 
			DO_WR 态产生写请求信号、数据和地址； 
			WAIT_WR_DONE 态判断写传输是否完成； 
			DO_RD 态产生读请求信号与地址； 
			WAIT_RD_DONE 态读取数据，并判断当前读操作是否成功。来实现以上设计目的。
			
			*/
			
			    reg motor_rd_err,motor_wr_err;  //高电平表示读取/写失败
			       
				reg [2:0]state;		
			    reg [6:0]data_cnt;		//表示数据传输进程	 
				 
			    localparam 
			        IDLE = 0,
			        DO_WR = 1,
			        WAIT_WR_DONE  = 2,
			        DO_RD = 3,
			        WAIT_RD_DONE = 4;
		
		    	always@(posedge Clk)
		        data_len <= num_cmd[3:0];
			        
			    always@(posedge Clk or negedge Rst_n)
			    if(!Rst_n)begin
			        state <= IDLE;
			        wrreg_req <= 1'd0;
			        addr <= 8'd0;
			        wrdata <= 8'd0;
			        data_cnt <= 7'd0;
			        motor_wr_err <= 1'd0;
			        motor_wr_done <= 1'd0;   
			        motor_rd_done <= 1'd0;
			        motor_rd_err <= 1'd0;
			        rdreg_req <= 1'd0;   
			        motor_rddata <= 32'd0;
		
			    end
			    else begin
			    case(state)
			        IDLE:
			            begin
			                wrreg_req <= 1'd0;
			                addr <= 8'd0;
			                wrdata <= 8'd0;
			                data_cnt <= 7'd0;
			                motor_wr_err <= 1'd0;   
			                motor_rd_done <= 1'd0;
			                motor_rd_err <= 1'd0;
			                rdreg_req <= 1'd0; 
	
			                if(cmd_valid && !num_cmd[7]&&num_cmd[3:0])			//num_cmd[7]为0代表写操作
			                    state <= DO_WR;
			                else if(cmd_valid && num_cmd[7])begin
			                    state <= DO_RD;
			                    motor_rddata <= 32'd0;
			                end
			                else
			                    state <= IDLE;
			            end
			                
			        DO_WR:
			            begin
			                wrreg_req <= 1'd1;
			                addr <= address;
			                state <= WAIT_WR_DONE;
		
		//					wrdata <= cmd_data;
		
			                case(data_cnt)		
			                    0:wrdata <= cmd_data;
			                    1:wrdata <= cmd_data;
			                    2:wrdata <= cmd_data;
			                    3:wrdata<= cmd_data;
			                    default:wrdata <= 0;
			                endcase
		
			            end
			            
			        WAIT_WR_DONE:
			            begin
			                wrreg_req <= 1'd0;
			                if(RW_Done)
							begin
			                    if(!ack)
								begin   //ACK为0表示有正常应答
			                        if(data_cnt >= num_cmd[3:0] - 1)
										begin
			                            state <= IDLE;
			                            motor_wr_done <= 1'd1;
			                            data_cnt <= 0;
										end
		
									else 
										begin
			                            state <= DO_WR;
			                            data_cnt <= data_cnt + 1'd1;    
										end    
		       
			                    end
			                    
								else begin  //ACK为1表示无应答
			                        state <= IDLE;
			                        motor_wr_err <= 1'd1;                 
			                    end
							end
			                
							else begin
			                    state <= WAIT_WR_DONE;
			                    data_cnt <= data_cnt;
			                end
			            end
			
			        DO_RD:
			            begin
			                rdreg_req <= 1'd1;
			                state <= WAIT_RD_DONE;
			                addr <= address;
			            end  
			                      
			        WAIT_RD_DONE:
			            begin
			                rdreg_req <= 1'd0;
			                if(RW_Done)begin
			                    if(!ack)begin   //ACK为0表示有正常应答
			                        case(data_cnt)
		
			                            0:motor_rddata[31:24] <= rddata;
			                            1:motor_rddata[23:16] <= rddata;
			                            2:motor_rddata[15:8] <= rddata;
			                            3:motor_rddata[7:0] <= rddata;
			                            default:;
			                        endcase
			                        if(data_cnt >= (num_cmd & 8'h7F) - 1)begin
			                            state <= IDLE;
			                            motor_rd_done <= 1'd1;
			                            data_cnt <= 0;
			                        end
			                        else begin
			                            state <= DO_RD;
			                            data_cnt <= data_cnt + 1'd1;    
			                        end           
			                    end
			                    else begin  //ACK为1表示无应答
			                        state <= IDLE;
			                        motor_rd_err <= 1'd1;                 
			                    end
			                end
			                else begin
			                    state <= WAIT_RD_DONE;
			                    data_cnt <= data_cnt;
			                end
			            end
			            
			            default:state <= IDLE;
			        endcase
			    end
endmodule    //Wheel_Instruction_Analysis

