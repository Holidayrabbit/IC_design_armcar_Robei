<!DOCTYPE Robei>
<Module Y="0" Parameters="" Parent="0" Include="" Width="900" X="0" File="Current/TFT_driver.model" Type="module" Class="module" Code="&#xa;&#x9;reg res;                    //(*mark_debug = &quot;true&quot;*)&#xa;&#x9;reg blk;                    //(*mark_debug = &quot;true&quot;*)&#xa;&#x9;reg dcx ;                   //(*mark_debug = &quot;true&quot;*)&#xa;&#x9;reg sda ;                   //(*mark_debug = &quot;true&quot;*)&#xa;&#x9;reg [2:0] CLK_cnt;          //(*mark_debug = &quot;true&quot;*)&#xa;&#x9;&#xa;&#x9;assign CLK = (CLK_cnt &lt;= 2) ? 1'b0 : 1'b1;             //CLK_cnt的值：0~5    系统时钟6分频&#xa;&#x9;assign MOSI = sda;          // 主机发送数据&#xa;&#x9;assign RES = res;           //复位信号&#xa;&#x9;assign DC = dcx;            // 数据或命令选择      用于区分写入显示屏的是数据还是命令&#xa;&#x9;assign BLK = blk;           //背光控制，默认开启，低电平关闭（不亮）空闲时刻&#xa;//&#x9;assign CS = 1'b0;&#xa;&#x9;parameter CMD  = 0;&#xa;&#x9;parameter DATA = 1;&#xa;&#x9;&#xa;&#x9;&#xa;&#x9;reg [6:0] delay_cnt = 0;           //用于延时&#xa;&#x9;reg [6:0] DELAY_TIME_SET;          //延时时间：  100ms&#xa;&#x9;//generate 1ms clk&#xa;&#x9;reg [15:0] clk_1ms_cnt = 0;&#xa;&#x9;always@(posedge clk)&#xa;&#x9;    if(clk_1ms_cnt >= 33_333)            //值：  0~33_333: 用于计数1ms&#xa;&#x9;        clk_1ms_cnt &lt;= 16'd0;&#xa;&#x9;    else&#xa;&#x9;        clk_1ms_cnt &lt;= clk_1ms_cnt + 1'b1;&#xa;&#x9;    &#xa;&#x9;wire clk_1ms;           //(*mark_debug = &quot;true&quot;*)&#xa;&#x9;&#xa;&#x9;assign clk_1ms = clk_1ms_cnt == 1;&#xa;&#x9;//#####################################main state machine\        主状态&#xa;&#x9;&#xa;&#x9;&#xa;&#x9;parameter  IDLE      = 7'b0000001;          //空闲&#xa;&#x9;parameter  RESET     = 7'b0000010;          //复位&#xa;&#x9;parameter  DELAY     = 7'b0000100;          //延时&#xa;&#x9;parameter  RESET_SET = 7'b0001000;          //复位？&#xa;&#x9;parameter  BLK_SET   = 7'b0010000;          //背光控制&#xa;&#x9;parameter  INIT      = 7'b0100000;          //数据输入SPI显示屏&#xa;&#x9;parameter  DISPLAY   = 7'b1000000;          //显示&#xa;&#x9;(* mark_debug=1 *)reg [6:0] main_state,next_main_state;       //(*mark_debug = &quot;true&quot;*)&#xa;&#x9;&#xa;&#x9;parameter  SPI_IDLE  = 5'b00001;           //SPI空闲      SPI状态&#xa;&#x9;parameter  SPI_START = 5'b00010;           //SPI开始&#xa;&#x9;parameter  SPI_SEND  = 5'b00100;           //传数&#xa;&#x9;parameter  SPI_WAIT  = 5'b01000;           //等待&#xa;&#x9;parameter  SPI_STOP  = 5'b10000;           //停止&#xa;&#x9;(* mark_debug=1 *)reg [4:0] spi_state,next_spi_state;     //(*mark_debug = &quot;true&quot;*)&#xa;&#x9;&#xa;&#x9;reg init_done;          //(*mark_debug = &quot;true&quot;*)       //SPI进入到停止状态的标志；若为1：主状态由INIT转为DISPLAY&#xa;&#x9;reg color;              //(*mark_debug = &quot;true&quot;*)       //INIT（SPI进入到停止状态）、DISPLAY为1，其他状态为0：  SPI_SEND到下一状态的判断标志；控制SPI传输的是数据还是命令（对应数据还是命令地址改变）；&#xa;&#x9;//&#xa;&#x9;wire rom_en;&#xa;&#x9;assign rom_en = color;&#xa;&#x9;assign clka = clk &amp;&amp; rom_en;&#xa;&#x9;assign ena = 1'b1;&#xa;&#x9;&#xa;&#x9;always@(posedge clk or negedge rstn)&#xa;&#x9;    if(!rstn)&#xa;&#x9;        main_state &lt;= IDLE;&#xa;&#x9;    else&#xa;&#x9;        main_state &lt;= next_main_state;&#xa;&#x9;&#xa;&#x9;always@(*)&#xa;&#x9;    begin&#xa;&#x9;        case(main_state)&#xa;&#x9;            IDLE : begin&#xa;&#x9;                    next_main_state = RESET;&#xa;&#x9;                end&#xa;&#x9;            RESET : begin&#xa;&#x9;                    next_main_state = DELAY;&#xa;&#x9;                end&#xa;&#x9;            DELAY : begin&#xa;&#x9;                    if(delay_cnt == DELAY_TIME_SET)&#xa;&#x9;                        next_main_state = (res == 0) ?  RESET_SET : (blk == 0) ? BLK_SET : INIT;&#xa;&#x9;                    else&#xa;&#x9;                        next_main_state = DELAY;&#xa;&#x9;                end&#xa;&#x9;            RESET_SET : begin&#xa;&#x9;                    next_main_state = DELAY;&#xa;&#x9;                end&#xa;&#x9;            BLK_SET : begin&#xa;&#x9;                    next_main_state = DELAY;&#xa;&#x9;                end&#xa;&#x9;            INIT : begin&#xa;&#x9;                    if(init_done)&#xa;&#x9;                        next_main_state = DISPLAY;&#xa;&#x9;                    else &#xa;&#x9;                        next_main_state = INIT;&#xa;&#x9;                end&#xa;&#x9;            DISPLAY : begin&#xa;&#x9;                        next_main_state = DISPLAY;&#xa;&#x9;                    end&#xa;&#x9;            default : begin&#xa;&#x9;                        next_main_state =  IDLE;&#xa;&#x9;                    end&#xa;&#x9;        endcase&#xa;&#x9;    end&#xa;&#x9;&#xa;&#x9;always@(posedge clk or negedge rstn)&#xa;&#x9;    if(!rstn)&#xa;&#x9;        begin&#xa;&#x9;           res &lt;= 1'b1;&#xa;&#x9;           blk &lt;= 1'b0;&#xa;&#x9;           init_done &lt;= 1'b0;&#xa;&#x9;           color &lt;= 1'b0;&#xa;&#x9;           delay_cnt &lt;= 7'd0;&#xa;&#x9;        end&#xa;&#x9;    else begin&#xa;&#x9;        case(main_state)&#xa;&#x9;            IDLE : begin&#xa;&#x9;                    res &lt;= 1'b1;&#xa;&#x9;                    blk &lt;= 1'b0;&#xa;&#x9;                    init_done &lt;= 1'b0;&#xa;&#x9;                    color &lt;= 1'b0;&#xa;&#x9;                    delay_cnt &lt;= 7'd0;&#xa;&#x9;                end &#xa;&#x9;            RESET : begin&#xa;&#x9;                    res &lt;= 1'b0;&#xa;&#x9;                    delay_cnt &lt;= 7'd0;&#xa;&#x9;                    DELAY_TIME_SET &lt;= 7'd100;//     100ms;&#xa;&#x9;                    //DELAY_TIME_SET &lt;= 7'd1;//   for test  1ms;&#xa;&#x9;                    end&#xa;&#x9;            DELAY : begin&#xa;&#x9;                    if(clk_1ms) begin&#xa;&#x9;                        if(delay_cnt == DELAY_TIME_SET)&#xa;&#x9;                            delay_cnt &lt;= 7'd0;&#xa;&#x9;                        else&#xa;&#x9;                            delay_cnt &lt;= delay_cnt + 1'b1;&#xa;&#x9;                    end&#xa;&#x9;                    else&#xa;&#x9;                        delay_cnt &lt;= delay_cnt;&#xa;&#x9;                    end&#xa;&#x9;            RESET_SET : begin&#xa;&#x9;                        delay_cnt &lt;= 7'd0;&#xa;&#x9;                        res &lt;= 1'b1;&#xa;&#x9;                        DELAY_TIME_SET &lt;= 7'd100;//ms;&#xa;&#x9;                        //DELAY_TIME_SET &lt;= 7'd1;//   for test  1ms;&#xa;&#x9;                        end&#xa;&#x9;            BLK_SET : begin&#xa;&#x9;                        blk &lt;= 1'b1;&#xa;&#x9;                        delay_cnt &lt;= 7'd0;&#xa;&#x9;                        DELAY_TIME_SET &lt;= 7'd100;//ms;&#xa;&#x9;                        //DELAY_TIME_SET &lt;= 7'd1;//   for test  1ms;&#xa;&#x9;                    end&#xa;&#x9;            INIT : begin&#xa;&#x9;                        delay_cnt &lt;= 7'd0;&#xa;&#x9;                        if(spi_state == SPI_STOP)begin&#xa;&#x9;                            color &lt;= 1'b1;&#xa;&#x9;                            init_done &lt;= 1'b1;end&#xa;&#x9;                        else&#xa;&#x9;                            init_done &lt;= 1'b0;&#xa;&#x9;                    end&#xa;&#x9;            DISPLAY : begin&#xa;&#x9;                            delay_cnt &lt;= 7'd0;&#xa;&#x9;                            color &lt;= 1'b1;&#xa;&#x9;                        end&#xa;&#x9;            default :;&#xa;&#x9;            endcase&#xa;&#x9;            end&#xa;&#x9;&#xa;&#x9;////////################################&#xa;&#x9;&#xa;&#x9;&#xa;&#x9;always@(posedge clk or negedge rstn)&#xa;&#x9;    if(!rstn)&#xa;&#x9;        spi_state &lt;= SPI_IDLE;&#xa;&#x9;    else begin&#xa;&#x9;        case(main_state)&#xa;&#x9;        INIT : begin&#xa;&#x9;            spi_state &lt;= next_spi_state;&#xa;&#x9;            end&#xa;&#x9;        DISPLAY : begin&#xa;&#x9;            spi_state &lt;= next_spi_state;&#xa;&#x9;            end&#xa;&#x9;        default : begin&#xa;&#x9;            spi_state &lt;= SPI_IDLE;&#xa;&#x9;            end&#xa;&#x9;        endcase&#xa;&#x9;    end&#xa;&#x9;(* mark_debug=1 *)reg [18:0] byte_addr;&#xa;&#x9;&#xa;&#x9;(* mark_debug=1 *)reg [2:0] bit_cnt;          //(*mark_debug = &quot;true&quot;*)&#xa;&#x9;(* mark_debug=1 *)reg [8:0] data_byte_init;   //(*mark_debug = &quot;true&quot;*)&#xa;&#x9;&#xa;&#x9;reg [6:0] wait_cnt = 0;     //(*mark_debug = &quot;true&quot;*)&#xa;&#x9;reg [6:0] delay_time;       //(*mark_debug = &quot;true&quot;*)&#xa;&#x9;&#xa;&#x9;&#xa;&#x9;assign addr = byte_addr;&#xa;&#x9;&#xa;&#x9;always@(*)&#xa;&#x9;    case(spi_state)&#xa;&#x9;        SPI_IDLE : begin&#xa;&#x9;                next_spi_state = SPI_START;&#xa;&#x9;            end&#xa;&#x9;        SPI_START:begin&#xa;&#x9;                next_spi_state = SPI_SEND;&#xa;&#x9;            end&#xa;&#x9;        SPI_SEND :begin&#xa;&#x9;                if(color == 0) begin&#xa;&#x9;                        if(byte_addr == 77 &amp;&amp; bit_cnt == 7 &amp;&amp; CLK_cnt == 5)&#xa;&#x9;                            next_spi_state = SPI_STOP;&#xa;&#x9;                        else    begin&#xa;&#x9;                            if(bit_cnt == 7 &amp;&amp; CLK_cnt == 5)&#xa;&#x9;                                next_spi_state = SPI_WAIT;&#xa;&#x9;                            else&#xa;&#x9;                            next_spi_state = SPI_SEND;&#xa;&#x9;                            end&#xa;&#x9;                end&#xa;&#x9;                else begin&#xa;&#x9;                    if(byte_addr == 460800 &amp;&amp; bit_cnt == 7 &amp;&amp; CLK_cnt == 5)&#xa;&#x9;                            next_spi_state = SPI_STOP;&#xa;&#x9;                    else    begin&#xa;&#x9;                                if(bit_cnt == 7 &amp;&amp; CLK_cnt == 5)&#xa;&#x9;                                    next_spi_state = SPI_WAIT;&#xa;&#x9;                                else&#xa;&#x9;                                    next_spi_state = SPI_SEND;&#xa;&#x9;                            end&#xa;&#x9;                   &#xa;&#x9;                    &#xa;&#x9;                    end&#xa;&#x9;            end&#xa;&#x9;        SPI_WAIT :begin&#xa;&#x9;                if(wait_cnt == delay_time)&#xa;&#x9;                    next_spi_state = SPI_SEND;&#xa;&#x9;                else&#xa;&#x9;                    next_spi_state = SPI_WAIT;&#xa;&#x9;            end&#xa;&#x9;        SPI_STOP :begin&#xa;&#x9;                next_spi_state = (main_state == INIT ) ? SPI_IDLE : SPI_STOP;&#xa;&#x9;            end&#xa;&#x9;        default :begin&#xa;&#x9;                next_spi_state = SPI_IDLE;&#xa;&#x9;            end&#xa;&#x9;    endcase&#xa;&#x9;&#xa;&#x9;always@(posedge clk or negedge rstn)&#xa;&#x9;    if(!rstn)&#xa;&#x9;        begin&#xa;&#x9;            CLK_cnt &lt;= 3'd0;&#xa;&#x9;            byte_addr &lt;= 19'd0;&#xa;&#x9;            bit_cnt &lt;= 3'd7;&#xa;&#x9;            dcx &lt;= 1'b0;&#xa;&#x9;            sda &lt;= 1'b1;&#xa;&#x9;            wait_cnt = 0;&#xa;&#x9;        end&#xa;&#x9;    else begin&#xa;&#x9;        case(spi_state)&#xa;&#x9;            SPI_IDLE :begin&#xa;&#x9;                CLK_cnt &lt;= 3'd0;&#xa;&#x9;                byte_addr &lt;= 19'd0;&#xa;&#x9;                dcx &lt;= 1'b0;&#xa;&#x9;                sda &lt;= 1'b1; &#xa;&#x9;                wait_cnt &lt;= 0;&#xa;&#x9;            end&#xa;&#x9;            SPI_START :begin&#xa;&#x9;                dcx &lt;= color ? DATA : CMD;&#xa;&#x9;                wait_cnt &lt;= 0;&#xa;&#x9;                CLK_cnt &lt;= CLK_cnt + 1'b1;&#xa;&#x9;                end&#xa;&#x9;            SPI_SEND : begin&#xa;&#x9;                wait_cnt &lt;= 0;&#xa;&#x9;                if(CLK_cnt ==5)&#xa;&#x9;                    CLK_cnt &lt;= 3'd0;&#xa;&#x9;                else&#xa;&#x9;                    CLK_cnt &lt;= CLK_cnt + 1'b1;&#xa;&#x9;&#xa;&#x9;        //###########  byte_addr ctrl##################&#xa;&#x9;                if(bit_cnt == 7 &amp;&amp; CLK_cnt == 4)&#xa;&#x9;                    if(color == 0) begin&#xa;&#x9;                        if(byte_addr == 77)&#xa;&#x9;                            byte_addr &lt;= 19'd0;&#xa;&#x9;                        else&#xa;&#x9;                            byte_addr &lt;= byte_addr + 1'b1;&#xa;&#x9;                    end&#xa;&#x9;                    else begin&#xa;&#x9;                         if(byte_addr == 460799)&#xa;&#x9;                            byte_addr &lt;= 19'd0;&#xa;&#x9;                        else&#xa;&#x9;                            byte_addr &lt;= byte_addr + 1'b1; &#xa;&#x9;                    end&#xa;&#x9;                else&#xa;&#x9;                        byte_addr &lt;= byte_addr; &#xa;&#x9;            //##########  dcx ctrl ########################&#xa;&#x9;                if(bit_cnt == 7 &amp;&amp; CLK_cnt == 5)&#xa;&#x9;                    dcx &lt;= color ? DATA : data_byte_init[8];&#xa;&#x9;                else&#xa;&#x9;                    dcx &lt;= dcx;//end&#xa;&#x9;            //#############  sda   ctrl  ######################&#xa;&#x9;                if(color) begin&#xa;&#x9;                    if(CLK_cnt == 1)&#xa;&#x9;                    begin&#xa;&#x9;                    sda &lt;= pic_data[bit_cnt];&#xa;&#x9;                    bit_cnt &lt;= bit_cnt - 1;&#xa;&#x9;                    end&#xa;&#x9;                    else&#xa;&#x9;                    begin&#xa;&#x9;                    sda &lt;= sda;&#xa;&#x9;                    bit_cnt &lt;= bit_cnt;&#xa;&#x9;                    end&#xa;&#x9;                end&#xa;&#x9;                else begin&#xa;&#x9;                    if(CLK_cnt == 1)&#xa;&#x9;                        begin&#xa;&#x9;                        sda &lt;= data_byte_init[bit_cnt];&#xa;&#x9;                        bit_cnt &lt;= bit_cnt - 1;&#xa;&#x9;                        end&#xa;&#x9;                    else&#xa;&#x9;                        begin&#xa;&#x9;                        sda &lt;= sda;&#xa;&#x9;                        bit_cnt &lt;= bit_cnt;&#xa;&#x9;                        end&#xa;&#x9;                end&#xa;&#x9;            end    &#xa;&#x9;            SPI_WAIT :begin&#xa;&#x9;                    if(clk_1ms) begin&#xa;&#x9;                        if(wait_cnt >= delay_time)&#xa;&#x9;                            wait_cnt &lt;= 7'd0;&#xa;&#x9;                        else&#xa;&#x9;                            wait_cnt &lt;= wait_cnt + 1'b1;&#xa;&#x9;                        end&#xa;&#x9;                    else begin&#xa;&#x9;                        wait_cnt &lt;= wait_cnt;&#xa;&#x9;                        end&#xa;&#x9;                end&#xa;&#x9;            SPI_STOP :begin&#xa;&#x9;                    CLK_cnt &lt;= 3'd0;&#xa;&#x9;                    byte_addr &lt;= 19'd0;&#xa;&#x9;                    dcx &lt;= 1'b1;&#xa;&#x9;                    sda &lt;= 1'b1; &#xa;&#x9;                end&#xa;&#x9;            default :;&#xa;&#x9;        endcase&#xa;&#x9;        end&#xa;&#x9;&#xa;&#x9;always@(posedge clk or negedge rstn)&#xa;&#x9;    if(!rstn)&#xa;&#x9;        delay_time &lt;= 7'd0;&#xa;&#x9;    else if(byte_addr == 65)&#xa;&#x9;        delay_time &lt;= color ? 7'd0 : 7'd120;&#xa;&#x9;        //delay_time &lt;= color ? 7'd0 : 7'd1;//for test 1ms&#xa;&#x9;    //else if(byte_addr == 29)&#xa;&#x9;        //delay_time &lt;= color ? 7'd0 : 7'd50;&#xa;&#x9;        //delay_time &lt;= color ? 7'd0 : 7'd1;//for test 1ms&#xa;&#x9;   // else if(byte_addr == 62)&#xa;&#x9;      //  delay_time &lt;= color ? 7'd0 : 7'd120;&#xa;&#x9;        //delay_time &lt;= color ? 7'd0 : 7'd1;//for test 1ms&#xa;&#x9;    else&#xa;&#x9;        delay_time &lt;= 7'd0;&#xa;&#x9;//############################ initial data and cmd ###################&#xa;&#x9;always@(*)&#xa;&#x9;    begin&#xa;&#x9;    case(byte_addr)   &#xa;&#x9;    0    : data_byte_init = {CMD,8'hE0}; //sleep out then wait 120ms&#xa;&#x9;    1    : data_byte_init = {DATA,8'h00}; &#xa;&#x9;    2    : data_byte_init = {DATA,8'h07};&#xa;&#x9;    3    : data_byte_init = {DATA,8'h0F};&#xa;&#x9;    4    : data_byte_init = {DATA,8'h0D};&#xa;&#x9;    5    : data_byte_init = {DATA,8'h1B};&#xa;&#x9;    6    : data_byte_init = {DATA,8'h0A};&#xa;&#x9;    7    : data_byte_init = {DATA,8'h3C};&#xa;&#x9;    8    : data_byte_init = {DATA,8'h78};&#xa;&#x9;    9    : data_byte_init = {DATA,8'h4A};&#xa;&#x9;    10   : data_byte_init = {DATA,8'h07};&#xa;&#x9;    11   : data_byte_init = {DATA,8'h0E};&#xa;&#x9;&#x9;12   : data_byte_init = {DATA,8'h09};&#xa;&#x9;&#x9;13   : data_byte_init = {DATA,8'h1B};&#xa;&#x9;&#x9;14   : data_byte_init = {DATA,8'h1E};&#xa;&#x9;    15   : data_byte_init = {DATA,8'h0F};//memory access control&#xa;&#x9;    &#xa;&#x9;    16   : data_byte_init = {CMD,8'hE1};&#xa;&#x9;    17   : data_byte_init = {DATA,8'h00};&#xa;&#x9;    18   : data_byte_init = {DATA,8'h22};&#xa;&#x9;    19   : data_byte_init = {DATA,8'h24};&#xa;&#x9;    20   : data_byte_init = {DATA,8'h06};&#xa;&#x9;    21   : data_byte_init = {DATA,8'h12};&#xa;&#x9;    22   : data_byte_init = {DATA,8'h07};&#xa;&#x9;    23   : data_byte_init = {DATA,8'h36};&#xa;&#x9;    24   : data_byte_init = {DATA,8'h47};&#xa;&#x9;    25   : data_byte_init = {DATA,8'h47};&#xa;&#x9;    26   : data_byte_init = {DATA,8'h06};&#xa;&#x9;    27   : data_byte_init = {DATA,8'h0A};&#xa;&#x9;    28   : data_byte_init = {DATA,8'h07};&#xa;&#x9;    29   : data_byte_init = {DATA,8'h30};&#xa;&#x9;    30   : data_byte_init = {DATA,8'h37};&#xa;&#x9;    31   : data_byte_init = {DATA,8'h0F};&#xa;&#x9;    &#xa;&#x9;    32   : data_byte_init = {CMD,8'hC0};&#xa;&#x9;    33   : data_byte_init = {DATA,8'h10};&#xa;&#x9;    34   : data_byte_init = {DATA,8'h10};&#xa;&#x9;    &#xa;&#x9;    35   : data_byte_init = {CMD,8'hC1};&#xa;&#x9;    36   : data_byte_init = {DATA,8'h41};&#xa;&#x9;    &#xa;&#x9;    37   : data_byte_init = {CMD,8'hC5};&#xa;&#x9;    38   : data_byte_init = {DATA,8'h00};&#xa;&#x9;    39   : data_byte_init = {DATA,8'h22};&#xa;&#x9;    40   : data_byte_init = {DATA,8'h80};&#xa;&#x9;    &#xa;&#x9;    41   : data_byte_init = {CMD,8'h36};&#xa;&#x9;    42   : data_byte_init = {DATA,8'h48};&#xa;&#x9;    &#xa;&#x9;    43   : data_byte_init = {CMD,8'h3A};&#xa;&#x9;    44   : data_byte_init = {DATA,8'h66};&#xa;&#x9;    &#xa;&#x9;    45   : data_byte_init = {CMD,8'hB0};&#xa;&#x9;    46   : data_byte_init = {DATA,8'h00};&#xa;&#x9;    &#xa;&#x9;    47   : data_byte_init = {CMD,8'hB1};&#xa;&#x9;    48   : data_byte_init = {DATA,8'hB0};&#xa;&#x9;    49   : data_byte_init = {CMD,8'h11};&#xa;&#x9;    &#xa;&#x9;    50   : data_byte_init = {CMD,8'hB4};&#xa;&#x9;    51   : data_byte_init = {DATA,8'h02};&#xa;&#x9;    &#xa;&#x9;    52   : data_byte_init = {CMD,8'hB6};&#xa;&#x9;    53   : data_byte_init = {DATA,8'h02};&#xa;&#x9;    54   : data_byte_init = {DATA,8'h02};&#xa;&#x9;    &#xa;&#x9;    55   : data_byte_init = {CMD,8'hB7};&#xa;&#x9;    56   : data_byte_init = {DATA,8'hC6};&#xa;&#x9;    &#xa;&#x9;    57   : data_byte_init = {CMD,8'hE9};&#xa;&#x9;    58   : data_byte_init = {DATA,8'h00};&#xa;&#x9;    &#xa;&#x9;    59   : data_byte_init = {CMD,8'hF7};&#xa;&#x9;    60   : data_byte_init = {DATA,8'hA9};&#xa;&#x9;    61   : data_byte_init = {DATA,8'h51};&#xa;&#x9;    62   : data_byte_init = {DATA,8'h2C};&#xa;&#x9;    63   : data_byte_init = {DATA,8'h82};&#xa;&#x9;    &#xa;&#x9;    64   : data_byte_init = {CMD,8'h11};&#xa;&#x9;//delay_ms(120);&#xa;&#x9;    65   : data_byte_init = {CMD,8'h29}; //display on cmd&#xa;&#x9;    66   : data_byte_init = {CMD,8'h2a};//列地址设置 0~319 &#xa;&#x9;    67   : data_byte_init = {DATA,8'h00};&#xa;&#x9;    68   : data_byte_init = {DATA,8'h00};&#xa;&#x9;    69   : data_byte_init = {DATA,8'h01};&#xa;&#x9;    70   : data_byte_init = {DATA,8'h3f};&#xa;&#x9;    71   : data_byte_init = {CMD,8'h2b};//行地址设置 0~479 &#xa;&#x9;    72   : data_byte_init = {DATA,8'h00};&#xa;&#x9;    73   : data_byte_init = {DATA,8'h00};&#xa;&#x9;    74   : data_byte_init = {DATA,8'h01};&#xa;&#x9;    75   : data_byte_init = {DATA,8'hdf};&#xa;&#x9;    76  : data_byte_init = {CMD,8'h2C};//储存器写 &#xa;&#x9;    default : data_byte_init = {DATA,8'h00};&#xa;&#x9;    endcase&#xa;&#x9;    end&#xa;&#x9;&#xa;&#x9;&#xa;&#x9;&#xa;&#xa;&#xa;" Name="TFT_driver" Color="#d3d3d3" Comment="" Height="600">
 <Port Y="0.183333" Inout="input" Datatype="wire" Parent="TFT_driver" Function="" Width="20" X="-0.0222222" Datasize="1" Side="left" Name="clk" Color="#ff0000" Height="20"/>
 <Port Y="0.383333" Inout="input" Datatype="wire" Parent="TFT_driver" Function="" Width="20" X="-0.0222222" Datasize="1" Side="left" Name="rstn" Color="#ffff00" Height="20"/>
 <Port Y="0.583333" Inout="input" Datatype="wire" Parent="TFT_driver" Function="" Width="20" X="-0.0222222" Datasize="8" Side="left" Name="pic_data" Color="#0000ff" Height="20"/>
 <Port Y="0.0833333" Inout="output" Datatype="wire" Parent="TFT_driver" Function="" Width="20" X="0.977778" Datasize="1" Side="right" Name="CLK" Color="#008000" Height="20"/>
 <Port Y="0.183333" Inout="output" Datatype="wire" Parent="TFT_driver" Function="" Width="20" X="0.977778" Datasize="1" Side="right" Name="MOSI" Color="#ffa500" Height="20"/>
 <Port Y="0.283333" Inout="output" Datatype="wire" Parent="TFT_driver" Function="" Width="20" X="0.977778" Datasize="1" Side="right" Name="RES" Color="#ffc0cb" Height="20"/>
 <Port Y="0.383333" Inout="output" Datatype="wire" Parent="TFT_driver" Function="" Width="20" X="0.977778" Datasize="1" Side="right" Name="DC" Color="#800080" Height="20"/>
 <Port Y="0.583333" Inout="output" Datatype="wire" Parent="TFT_driver" Function="" Width="20" X="0.977778" Datasize="19" Side="right" Name="addr" Color="#808080" Height="20"/>
 <Port Y="0.683333" Inout="output" Datatype="wire" Parent="TFT_driver" Function="" Width="20" X="0.977778" Datasize="1" Side="right" Name="clka" Color="#6495ed" Height="20"/>
 <Port Y="0.783333" Inout="output" Datatype="wire" Parent="TFT_driver" Function="" Width="20" X="0.977778" Datasize="1" Side="right" Name="ena" Color="#deb887" Height="20"/>
 <Port Y="0.483333" Inout="output" Datatype="wire" Parent="TFT_driver" Function="" Width="20" X="0.977778" Datasize="1" Side="right" Name="BLK" Color="#008080" Height="20"/>
</Module>
