module LM75A_i2c_control(
	Clk,
	Rst_n,
	rdreg_req,
	rddata,
	RW_Done,
	ack,
	i2c_sclk,
	i2c_sdat);

	//---Ports declearation: generated by Robei---
	input Clk;
	input Rst_n;
	input rdreg_req;
	output [7:0] rddata;
	output RW_Done;
	output ack;
	output i2c_sclk;
	inout i2c_sdat;

	wire Clk;
	wire Rst_n;
	wire rdreg_req;
	reg [7:0] rddata;
	reg RW_Done;
	reg ack;
	wire i2c_sclk;
	wire i2c_sdat;

	//----Code starts here: integrated by Robei-----
			localparam  lm75a_address=7'b1001_000; 
		
		
		
			reg [5:0]Cmd;
			reg [7:0]Tx_DATA;
			wire Trans_Done;
			wire ack_o;
			reg Go;
		
			//buffer for input data or out put data
			 reg [7:0] temp_out_reg;
			 reg [7:0] temp_in_Mreg;
			 reg [7:0] temp_in_Lreg;
			
		
			
			wire [7:0]Rx_DATA;
			reg [10:0] data_LM75A; //temperature data
			
			localparam 
				WR   = 6'b000001,   //写请求
				STA  = 6'b000010,   //起始位请求
				RD   = 6'b000100,   //读请求
				STO  = 6'b001000,   //停止位请求
				ACK  = 6'b010000,   //应答位请求
				NACK = 6'b100000;   //无应答请求
		
		
			
			reg [6:0]state;
			reg [7:0]cnt;
			
			localparam
				IDLE         = 7'b0000001,   //空闲状态
				WR_REG       = 7'b0000010,   //写寄存器状态
				WAIT_WR_DONE = 7'b0000100,   //等待写寄存器完成状态
				WR_REG_DONE  = 7'b0001000,   //写寄存器完成状态
				RD_REG       = 7'b0010000,   //读寄存器状态
				WAIT_RD_DONE = 7'b0100000,   //等待读寄存器完成状态
				RD_REG_DONE  = 7'b1000000;   //读寄存器完成状态
			
			always@(posedge Clk or negedge Rst_n)
			if(!Rst_n)begin
				Cmd <= 6'd0;
				Tx_DATA <= 8'd0;
				Go <= 1'b0;
				rddata <= 0;
				state <= IDLE;
				ack <= 0;
			end
			else begin
				case(state)
					IDLE:
						begin
							cnt <= 0;
							ack <= 0;
							RW_Done <= 1'b0;					
							if(rdreg_req)
								state <= RD_REG;
							else
								state <= IDLE;
						end					
						
					RD_REG:
						begin
							state <= WAIT_RD_DONE;
							case(cnt)
								0:write_byte(WR | STA, {lm75a_address,1'b1});			//发送lm75a的地址和读信号（1）
								1:read_byte(RD | ACK);
								2:read_byte(RD | NACK | STO);
								default:;
							endcase
						end
						
					WAIT_RD_DONE:
						begin
							Go <= 1'b0; 
							if(Trans_Done)begin
								if(cnt <= 1)
									ack <= ack | ack_o;
								case(cnt)
									0: begin cnt <= 1; state <= RD_REG;end
									1: 
										begin 
											
											temp_in_Mreg <= Rx_DATA;
											cnt <= 2;
											state <= RD_REG;
		
										end
											
									2: begin
											temp_in_Lreg <= Rx_DATA;
											state <= RD_REG_DONE;
										end
		
									default:state <= IDLE;
								endcase
							end
						end
						
					RD_REG_DONE:
						begin
							RW_Done <= 1'b1;
							if(!temp_in_Mreg[7]) //the value of the temperature data is judged by the highest bit.
			                       data_LM75A<={temp_in_Mreg,temp_in_Lreg[7:5]};
			                else
			                       data_LM75A<=~{temp_in_Mreg,temp_in_Lreg[7:5]}+1;
							
							/*
								temp_decade<=(data_LM75A>>3)/10; //data_LM75A*125/10000, if(data_LM75A<100)			//温度的十位
			                    temp_unit<=(data_LM75A>>3)%10;																							//温度的个位
			                    temp_decimal=(data_LM75A*125/100)%10;																				//温度的小数位
		
							*/
							rddata <= temp_in_Mreg;
							//rddata <= data_LM75A[10:3];
							state <= IDLE;				
						end
					default:state <= IDLE;
				endcase
			end
			
			task read_byte;
				input [5:0]Ctrl_Cmd;
				begin
					Cmd <= Ctrl_Cmd;
					Go <= 1'b1; 
				end
			endtask
			
			task write_byte;
				input [5:0]Ctrl_Cmd;
				input [7:0]Wr_Byte_Data;
				begin
					Cmd <= Ctrl_Cmd;
					Tx_DATA <= Wr_Byte_Data;
					Go <= 1'b1; 
				end
			endtask
	//---Module instantiation---
	LM75A_i2c_bit_shifter LM75A_i2c_bit_shifter2(
		.Clk(Clk),
		.Rst_n(Rst_n),
		.Cmd(Cmd),
		.Go(Go),
		.Tx_DATA(Tx_DATA),
		.Rx_DATA(Rx_DATA),
		.Trans_Done(Trans_Done),
		.ack_o(ack_o),
		.i2c_sclk(i2c_sclk),
		.i2c_sdat(i2c_sdat));

endmodule    //LM75A_i2c_control

